/////////////////////////////////////////////////////////////////////////////
// resamplemesh.cpp - Used to create a regularly resampled mesh (in 2.5D) from 
// an existing mesh using 2D interpolation of height values across triangles
//

#include "resamplemesh.hpp"

#include "simplematrix.hpp"
#include "coordtransforms.hpp"
#include "stats.hpp"

#include <gsl/gsl_multifit.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_blas.h>

#include <vector>
#include <sstream>
#include <fstream>
#include <iostream>

#include "tinyply.hpp"
using namespace tinyply;

#define BUFFERSIZE 2048

#include <time.h>

// Vertex - Simple vertex struct
typedef struct Vertex {
  float x,y,z;  
} Vertex;

// Face - Simple face structure
typedef struct Face {
	unsigned int nverts;
	int *verts;
} Face;

// FreePoints3D - Clean up points
void FreePoints3D(Points3D *points3d)
{
    if (points3d->n > 0) {
        free(points3d->X);
        free(points3d->Y);
        free(points3d->Z);
    }
}

// FreeTriData - Clean up tridata
void FreeTriData(TriData *tridata) {
    if (tridata->n > 0) {
        free(tridata->first);
        free(tridata->second);
        free(tridata->third);
    }
}

// GetPointsfromSinglePly - function used to get vertex and face data from ply
int GetPointsfromSinglePly(const std::string & filename, Points3D *points3d, TriData *tridata) 
{
	
	try
	{
		// Read the file and create a std::istringstream suitable
		// for the lib -- tinyply does not perform any file i/o.
		std::ifstream ss(filename, std::ios::binary);

		// Parse the ASCII header fields
		PlyFile file(ss);

		//for (auto e : file.get_elements())
		//{ }

		// Define containers to hold the extracted data. The type must match
		// the property type given in the header. Tinyply will interally allocate the
		// the appropriate amount of memory.
		std::vector<float> verts;
		std::vector<uint32_t> faces;

		uint32_t vertexCount, faceCount;
		vertexCount = faceCount = 0;

		vertexCount = file.request_properties_from_element("vertex", { "x", "y", "z" }, verts);
		faceCount = file.request_properties_from_element("face", { "vertex_indices" }, faces, 3);
		
		if ( (vertexCount == 0) && (faceCount == 0) ) {
			printf("Invalid play file\n");
			return -1;
		}
		else if ( (vertexCount == 0) || (faceCount == 0) ) {
			printf("ply file does not contain appropriate mesh geometry (nvertex: %d, nface: %d)\n",vertexCount,faceCount);
			return -1;
		}
		
		// Now populate the vectors...
		file.read(ss);

		// Good place to put a breakpoint!
		//std::cout << "\tRead " << verts.size() << " total vertices (" << vertexCount << " properties)." << std::endl;
		//std::cout << "\tRead " << faces.size() << " total faces (triangles) (" << faceCount << " properties)." << std::endl;
		
		// Copy data into point/tri data structures
		points3d->n = vertexCount;
		points3d->X = (double*)malloc(points3d->n*sizeof(double));
		points3d->Y = (double*)malloc(points3d->n*sizeof(double));
		points3d->Z = (double*)malloc(points3d->n*sizeof(double));
		for (int i = 0; i < vertexCount; i++) {
			points3d->X[i] = verts[3*i];
			points3d->Y[i] = verts[3*i+1];
			points3d->Z[i] = verts[3*i+2];
		}
		tridata->n = faceCount;
		tridata->first = (int*)malloc(tridata->n*sizeof(int));
		tridata->second = (int*)malloc(tridata->n*sizeof(int));
		tridata->third = (int*)malloc(tridata->n*sizeof(int));
		for (int i = 0; i < faceCount; i++) {
			tridata->first[i] = faces[3*i];
			tridata->second[i] = faces[3*i+1];
			tridata->third[i] = faces[3*i+2];
		}
		
	}

	catch (const std::exception & e)
	{
		std::cerr << "Caught exception: " << e.what() << std::endl;
		return -1;
	}
	
	return 0;
	
}
	
// CreateTotalTriPly - Creates ply file of triangulated surface
int CreateTotalTriPly(const std::string & filename, Points3D *points3d, TriData *tridata) 
{
	
	// Copy vertex/triangle data to vectors
	std::vector<float> verts(3*points3d->n);
	std::vector<int32_t> vertexIndicies(3*tridata->n);
	for (int i = 0; i < points3d->n; i++) {
		verts[3*i] = points3d->X[i];
		verts[3*i+1] = points3d->Y[i];
		verts[3*i+2] = points3d->Z[i];
	}
	for (int i = 0; i < tridata->n; i++) {
		vertexIndicies[3*i] = tridata->third[i];
		vertexIndicies[3*i+1] = tridata->second[i];
		vertexIndicies[3*i+2] = tridata->first[i];
	}
	
	// write to file
	std::filebuf fb;
	fb.open(filename, std::ios::out | std::ios::binary);
	std::ostream outputStream(&fb);

	PlyFile myFile;

	myFile.add_properties_to_element("vertex", { "x", "y", "z" }, verts);

	// List property types must also be created with a count and type of the list (data property type
	// is automatically inferred from the type of the vector argument). 
	myFile.add_properties_to_element("face", { "vertex_indices" }, vertexIndicies, 3, PlyProperty::Type::UINT8);

	myFile.comments.push_back("generated by tinyply");
	myFile.write(outputStream, true);

	fb.close();
	
	return 0;
	
}

int nextind(int *clipped, int ind, int n) {
    int j = ind+1;
    for (int i = 0; i < (n-1); i++) {
        if (j >= n) {
            j = 0;
        }
        if (clipped[j] == 0) {
            return(j);
        }
        j++;
    }
    return(-1);
}

int intriangle(double x, double y, double x0, double y0, double x1, double y1, double x2, double y2) 
{

	double a1 = (y1 - y2);
	double b1 = (x2 - x1);
	double c1 = -a1*x2 - b1*y2;
	double a2 = (y2 - y0);
	double b2 = (x0 - x2);
	double c2 = -a2*x2 - b2*y2;
	double d = (y1 - y2)*(x0 - x2) + (x2 - x1)*(y0 - y2);
	
	if (d == 0.0) { // not a proper triangle, skip
		return(0);
	}
	
	double w0 = (a1*x + b1*y + c1)/d;
	double w1 = (a2*x + b2*y + c2)/d;
	double w2 = 1.0 - w0 - w1;
	//printf("W: [%f %f %f]\n",w0,w1,w2);
	if ( (w0 >= 0) && (w0 <= 1) && (w1 >= 0) && (w1 <= 1) && (w2 >= 0) && (w2 <= 1) ) {
	    return(1);
	}
	else {
	    return(0);
	}
	
}

// compute_planefit - Computes a plane of best fit to the data in a set of 3D points
// and returns the transformation parameters to rotate to a horizontal plane
void compute_planefit(Points3D *points3d, double *R, int b_return_points, Points3D *points3d_fitted)
{
    
    gsl_matrix *H, *cov;
    gsl_vector *z, *x;
    double chisq;
    
    double xmax, xmin, ymax, ymin;
    double i_plane[3], j_plane[3], j_dir[3], k_plane[3];
    double dist;
    double unitmat[3];
	double P[3], P2[3];
	
	// Fit ground plane to 3D points
	H = gsl_matrix_alloc(points3d->n,3);
	cov = gsl_matrix_alloc(3,3);
    z = gsl_vector_alloc(points3d->n);
    x = gsl_vector_alloc(3);
    for (int i = 0; i < points3d->n; i++) {
    	gsl_matrix_set (H, i, 0, -points3d->X[i]);
        gsl_matrix_set (H, i, 1, -points3d->Y[i]);
        gsl_matrix_set (H, i, 2, -1.0);   
        gsl_vector_set (z, i, points3d->Z[i]);
    }
    gsl_multifit_linear_workspace *work = gsl_multifit_linear_alloc(points3d->n,3);
	gsl_multifit_linear(H, z, x, cov, &chisq, work);
    //printf("x: [%f %f %f]\n",gsl_vector_get(x,0),gsl_vector_get(x,1),gsl_vector_get(x,2));
    
    xmax = max(points3d->X,points3d->n);
    xmin = min(points3d->X,points3d->n);
    ymax = max(points3d->Y,points3d->n);
    ymin = min(points3d->Y,points3d->n);
    
    i_plane[0] = xmax-xmin;
    i_plane[1] = 0;
    i_plane[2] = -gsl_vector_get(x,0)*xmax - gsl_vector_get(x,2) - (-gsl_vector_get(x,0)*xmin - gsl_vector_get(x,2));
    dist = sqrt(i_plane[0]*i_plane[0] + i_plane[1]*i_plane[1] + i_plane[2]*i_plane[2]);
    i_plane[0] = i_plane[0]/dist;
    i_plane[1] = i_plane[1]/dist;
    i_plane[2] = i_plane[2]/dist;
    
    j_dir[0] = 0;
    j_dir[1] = ymax-ymin;
    j_dir[2] = -gsl_vector_get(x,1)*ymax - gsl_vector_get(x,2) - (-gsl_vector_get(x,1)*ymin - gsl_vector_get(x,2));
    dist = sqrt(j_dir[0]*j_dir[0] + j_dir[1]*j_dir[1] + j_dir[2]*j_dir[2]);
    j_dir[0] = j_dir[0]/dist;
    j_dir[1] = j_dir[1]/dist;
    j_dir[2] = j_dir[2]/dist;
    
    cross3x3(i_plane,j_dir,k_plane);
    cross3x3(k_plane,i_plane,j_plane);
    
    unitmat[0] = 1.0;	unitmat[1] = 0.0;	unitmat[2] = 0.0;
    R[0] = dot3x3(i_plane, unitmat);
    R[3] = dot3x3(j_plane, unitmat);
    R[6] = dot3x3(k_plane, unitmat);
    
    unitmat[0] = 0.0;	unitmat[1] = 1.0;	unitmat[2] = 0.0;
    R[1] = dot3x3(i_plane, unitmat);
    R[4] = dot3x3(j_plane, unitmat);
    R[7] = dot3x3(k_plane, unitmat);
    
    unitmat[0] = 0.0;	unitmat[1] = 0.0;	unitmat[2] = 1.0;
    R[2] = dot3x3(i_plane, unitmat);
    R[5] = dot3x3(j_plane, unitmat);
    R[8] = dot3x3(k_plane, unitmat);
    
    // Create new set of trasnformed points
    if (b_return_points == 1) {
		points3d_fitted->n = points3d->n;
		points3d_fitted->X = (double*)malloc(points3d_fitted->n*sizeof(double));
		points3d_fitted->Y = (double*)malloc(points3d_fitted->n*sizeof(double));
		points3d_fitted->Z = (double*)malloc(points3d_fitted->n*sizeof(double));
		for (int i = 0; i < points3d->n; i++) {
			P[0] = points3d->X[i];
			P[1] = points3d->Y[i];
			P[2] = points3d->Z[i];
			MatVectorMult3x3(R, P, P2);
			points3d_fitted->X[i] = P2[0];
			points3d_fitted->Y[i] = P2[1];
			points3d_fitted->Z[i] = P2[2];
		}
    }
    
	// Clean up
	gsl_multifit_linear_free(work);
	gsl_matrix_free(H);
	gsl_matrix_free(cov);
    gsl_vector_free(z);
    gsl_vector_free(x);
   
}

void InitGridMap(GridMap *gridmap, Points3D *points3d, double grid_res, double xfrac_off, double yfrac_off)
{
    gridmap->grid_res = grid_res;
    
    double xmin = min(points3d->X,points3d->n);
    double xmax = max(points3d->X,points3d->n);
    double ymin = min(points3d->Y,points3d->n);
    double ymax = max(points3d->Y,points3d->n);
    
    gridmap->xoffset = xmin + grid_res*xfrac_off;
    gridmap->yoffset = ymin + grid_res*yfrac_off;
    
    gridmap->nx = ceil((xmax-xmin)/grid_res) + 1;
    gridmap->ny = ceil((ymax-ymin)/grid_res) + 1;
    
    gridmap->grid_heights = (double**)malloc(gridmap->nx*sizeof(double*));
    gridmap->grid_occ = (int**)malloc(gridmap->nx*sizeof(int*));
    for (int i = 0; i < gridmap->nx; i++) {
        gridmap->grid_heights[i] = (double*)malloc(gridmap->ny*sizeof(double));
        gridmap->grid_occ[i] = (int*)malloc(gridmap->ny*sizeof(int));
        for (int j = 0; j < gridmap->ny; j++) {
            gridmap->grid_heights[i][j] = 0.0;
            gridmap->grid_occ[i][j] = 0;
        }
    }
    
}

void FreeGridMap(GridMap *gridmap)
{
    for (int i = 0; i < gridmap->nx; i++) {
        free(gridmap->grid_heights[i]);
    }
    free(gridmap->grid_heights);
    for (int i = 0; i < gridmap->nx; i++) {
        free(gridmap->grid_occ[i]);
    }
    free(gridmap->grid_occ);
}

// InterpTritoGridMap - Function used to rasterise interpolated values into a triangle
void InterpTritoGridMap(double x0a, double y0a, double x1a, double y1a, double x2a, double y2a,
	double val0, double val1, double val2, GridMap *gridmap, int label) {
	
	double x0, x1, x2, y0, y1, y2;
	double w0, w1, w2; 
	double xvals[3], yvals[3];
	double xmin, xmax, ymin, ymax;
	int i2, j2;
	
	x0 = (x0a-gridmap->xoffset)/gridmap->grid_res;
	x1 = (x1a-gridmap->xoffset)/gridmap->grid_res;
	x2 = (x2a-gridmap->xoffset)/gridmap->grid_res;
	y0 = (y0a-gridmap->yoffset)/gridmap->grid_res;
	y1 = (y1a-gridmap->yoffset)/gridmap->grid_res;
	y2 = (y2a-gridmap->yoffset)/gridmap->grid_res;
	
	xvals[0] = x0;
	xvals[1] = x1;
	xvals[2] = x2;
	yvals[0] = y0;
	yvals[1] = y1;
	yvals[2] = y2;
	xmin = min(xvals,3);
	xmax = max(xvals,3);
	ymin = min(yvals,3);
	ymax = max(yvals,3);
	
	// Compute barycentric coordinates
	double a1 = (y1 - y2);
	double b1 = (x2 - x1);
	double c1 = -a1*x2 - b1*y2;
	double a2 = (y2 - y0);
	double b2 = (x0 - x2);
	double c2 = -a2*x2 - b2*y2;
	double d = (y1 - y2)*(x0 - x2) + (x2 - x1)*(y0 - y2);
	
	if (d == 0.0) { // not a proper triangle, skip
		return;
	}
	
	// loop through potential grid values
	for (int i = (int)ceil(xmin); i <= (int)floor(xmax); i++) {
		for (int j = (int)ceil(ymin); j <= (int)floor(ymax); j++) {
			
			i2 = i;
			j2 = j;
			if (i2 < 0) {
				i2 = 0;
			}
			if (i2 >= gridmap->nx) {
				i2 = gridmap->nx-1;
			}
			if (j2 < 0) {
				j2 = 0;
			}
			if (j2 >= gridmap->ny) {
				j2 = gridmap->ny-1;
			}
			//if ( (i < 0) || (i > 99) || (j < 0) || (j > 99) ) {
			//	printf("ij(100): %d %d %d %d, label: %d\n",i,j,i2,j2,label);
			//}
			
			// check if in bounds
			w0 = (a1*((double)i) + b1*((double)j) + c1)/d;
			w1 = (a2*((double)i) + b2*((double)j) + c2)/d;
			w2 = 1.0 - w0 - w1;
			if ( (w0 >= 0) && (w0 <= 1) && (w1 >= 0) && (w1 <= 1) && (w2 >= 0) && (w2 <= 1) ) {
				if (label == -1) {
					double z = w0*val0 + w1*val1 + w2*val2;
					gridmap->grid_heights[i2][j2] = gridmap->grid_heights[i2][j2] + z;
					gridmap->grid_occ[i2][j2]++;
					/*if (gridmap->grid_occ[i][j] == 0) {
						gridmap->grid_occ[i][j] = 1;
						gridmap->grid_heights[i][j] = z;
					}
					else if (z < gridmap->grid_heights[i][j]) {
						gridmap->grid_heights[i][j] = z;
					}
					else {
					}*/
			    }
			    else {
			    	//printf("Filling\n");
			    	gridmap->grid_occ[i2][j2] = label;
			    	//printf("Done\n");
			    }
				//points3d->X[points3d->n] = grid_res*(double)i;
				//points3d->Y[points3d->n] = grid_res*(double)j;
				//points3d->Z[points3d->n] = w0*val0 + w1*val1 + w2*val2;
				//points3d->n++;
			}
			
		}
	}
	
}

// CreateSurffromGrid - Used to create and point cloud and triangles from a grid DEM
void CreateSurffromGrid(GridMap *gridmap, Points3D *points3d, TriData *tridata) 
{
    
    // Count points and faces
    int npoints = 0;
    for (int i = 0; i < gridmap->nx; i++) {
        for (int j = 0; j < gridmap->ny; j++) {
            if (gridmap->grid_occ[i][j] == 1) {
                npoints++;
            }
        }
    }
    int nfaces = 0;
    for (int i = 0; i < (gridmap->nx-1); i++) {
        for (int j = 0; j < (gridmap->ny-1); j++) {
            if ( (gridmap->grid_occ[i][j] == 1) &&
               (gridmap->grid_occ[i+1][j] == 1) &&
               (gridmap->grid_occ[i][j+1] == 1) ) {
                nfaces++;
            }
            if ( (gridmap->grid_occ[i+1][j+1] == 1) &&
               (gridmap->grid_occ[i+1][j] == 1) &&
               (gridmap->grid_occ[i][j+1] == 1) ) {
                nfaces++;
            }
        }
    }
    
    // Initialise points and faces
    points3d->n = npoints;
    points3d->nmem = points3d->n;
    points3d->X = (double*)malloc(points3d->n*sizeof(double));
    points3d->Y = (double*)malloc(points3d->n*sizeof(double));
    points3d->Z = (double*)malloc(points3d->n*sizeof(double));
    
    tridata->n = nfaces;
    tridata->first = (int*)malloc(tridata->n*sizeof(int));
    tridata->second = (int*)malloc(tridata->n*sizeof(int));
    tridata->third = (int*)malloc(tridata->n*sizeof(int));
    
    // Initialise data structure to track point index
    int **grid_ref = (int**)malloc(gridmap->nx*sizeof(int*));
    for (int i = 0; i < gridmap->nx; i++) {
        grid_ref[i] = (int*)malloc(gridmap->ny*sizeof(int));
        for (int j = 0; j < gridmap->ny; j++) {
            grid_ref[i][j] = -1;
        }
    }
    
    // Grab points and generate triangles
    npoints = 0;
    for (int i = 0; i < gridmap->nx; i++) {
        for (int j = 0; j < gridmap->ny; j++) {
            if (gridmap->grid_occ[i][j] == 1) {
                points3d->X[npoints] = gridmap->grid_res*(double)i + gridmap->xoffset;
                points3d->Y[npoints] = gridmap->grid_res*(double)j + gridmap->yoffset;
                points3d->Z[npoints] = gridmap->grid_heights[i][j];
                grid_ref[i][j] = npoints;
                npoints++;
            }
        }
    }
    nfaces = 0;
    for (int i = 0; i < (gridmap->nx-1); i++) {
        for (int j = 0; j < (gridmap->ny-1); j++) {
            if ( (gridmap->grid_occ[i][j] == 1) &&
               (gridmap->grid_occ[i+1][j] == 1) &&
               (gridmap->grid_occ[i][j+1] == 1) ) {
                //tridata->first[nfaces] = grid_ref[i][j];
                //tridata->second[nfaces] = grid_ref[i+1][j];
                //tridata->third[nfaces] = grid_ref[i][j+1];
                tridata->first[nfaces] = grid_ref[i][j];
                tridata->second[nfaces] = grid_ref[i][j+1];
                tridata->third[nfaces] = grid_ref[i+1][j];
                nfaces++;
            }
            if ( (gridmap->grid_occ[i+1][j+1] == 1) &&
               (gridmap->grid_occ[i+1][j] == 1) &&
               (gridmap->grid_occ[i][j+1] == 1) ) {
                //tridata->first[nfaces] = grid_ref[i+1][j];
                //tridata->second[nfaces] = grid_ref[i+1][j+1];
                //tridata->third[nfaces] = grid_ref[i][j+1];
                tridata->first[nfaces] = grid_ref[i+1][j];
                tridata->second[nfaces] = grid_ref[i][j+1];
                tridata->third[nfaces] = grid_ref[i+1][j+1];
                nfaces++;
            }
        }
    }
    
    //printf("CreateSurffromGrid Check: points: (%d/%d), tri: (%d/%d)\n",
    //    npoints,points3d->n,nfaces,tridata->n);
    
}

// Resamplegridtri - Used to resample a 2.5D triangulated surface model to a specified grid resolution
void Resample_GridTri(Points3D *points3d, TriData *tridata, double sample_size,
    Points3D *points3d_resampled, TriData *tridata_resampled, double xfrac_off, double yfrac_off)
{
    
    GridMap gridmap;
    
    // Setup grid data
    InitGridMap(&gridmap, points3d, sample_size, xfrac_off, yfrac_off);
    printf("Approx. Mesh Size: grid-size: [%dx%d], vertices: %d, faces: %d\n",gridmap.nx,gridmap.ny,gridmap.nx*gridmap.ny,2*(gridmap.nx-1)*(gridmap.ny-1));
    
    // Cycle through triangles, raster into grid
    for (int i = 0; i < tridata->n; i++) {
    	InterpTritoGridMap(points3d->X[tridata->first[i]], points3d->Y[tridata->first[i]], 
    		points3d->X[tridata->second[i]], points3d->Y[tridata->second[i]], 
    		points3d->X[tridata->third[i]], points3d->Y[tridata->third[i]], 
			points3d->Z[tridata->first[i]], points3d->Z[tridata->second[i]], points3d->Z[tridata->third[i]], 
			&gridmap, -1);
    }
    
    // average heights
    for (int i = 0; i < gridmap.nx; i++) {
        for (int j = 0; j < gridmap.ny; j++) {
            if (gridmap.grid_occ[i][j] > 0) {
                gridmap.grid_heights[i][j] = gridmap.grid_heights[i][j]/gridmap.grid_occ[i][j];
                gridmap.grid_occ[i][j] = 1;
            }
        }
    }
    
    // Create point cloud and triangulation from grid
    CreateSurffromGrid(&gridmap, points3d_resampled, tridata_resampled);
    
    printf("Actual. Mesh Size: vertices: %d, faces: %d\n",points3d_resampled->n,tridata_resampled->n);
    
    // Clean up
    FreeGridMap(&gridmap);
    
}

int main(int argc, char **argv) 
{
    
    Points3D points3d;
    TriData tridata;
   	Points3D points3d_resampled;
   	TriData tridata_resampled;
   	double R[9];
   	
    // Check arguements
	if (!(argc == 5)) {
		printf("Usage: resamplemesh <plyfile> <resample grid size> <use plane of bestfit (0/1)> <output_plyfile>\n");
		printf("======================\n");
		printf("\n");
		return -1;
    }
	
	printf("resamplemesh: Loading data ...\n");
	
	// Read in ply file for terrain structure
	if (GetPointsfromSinglePly(argv[1], &points3d, &tridata) != 0) {
		printf("resamplemesh: Can't read surface.ply file ...\n");
		return -1;
	}
	
	// get other arguments
	double grid_res = atof(argv[2]);
	int bUsePlane = atoi(argv[3]);
	
	printf("resamplemesh: Data loaded, terrain points/faces: %d/%d ...\n",points3d.n,tridata.n);
   	
   	// Compute extents of model
   	double BoundCoords[4];
   	BoundCoords[0] = min(points3d.X,points3d.n);
   	BoundCoords[1] = max(points3d.X,points3d.n);
   	BoundCoords[2] = min(points3d.Y,points3d.n);
   	BoundCoords[3] = max(points3d.Y,points3d.n);
   	printf("Bounding Coords: [%f %f %f %f]\n",BoundCoords[0],BoundCoords[1],BoundCoords[2],BoundCoords[3]);
   	
	// Re-compute mesh vertices for plane of best fit
	if (bUsePlane == 1) {
		printf("resamplemesh: Transforming to plane-of-best-fit ...\n");
   		compute_planefit(&points3d, R, 1, &points3d_resampled);
   		for (int i = 0; i < points3d.n; i++) {
			points3d.X[i] = points3d_resampled.X[i];
			points3d.Y[i] = points3d_resampled.Y[i];
			points3d.Z[i] = points3d_resampled.Z[i];
		}
		FreePoints3D(&points3d_resampled);
   	}
	
	// Re-sample Surface
	printf("resamplemesh: re-sampling to grid ...\n");
	Resample_GridTri(&points3d, &tridata, grid_res,
		&points3d_resampled, &tridata_resampled, 0.0001, 0.0);
	
	// Output re-sampled ply file
	if (CreateTotalTriPly(argv[4], &points3d_resampled, &tridata_resampled) != 0) {
		printf("resamplemesh: error writing ply file ...\n");
		return -1;
	}
	
	// Clean up
	FreePoints3D(&points3d_resampled);
	FreeTriData(&tridata_resampled);
	FreePoints3D(&points3d);
	FreeTriData(&tridata);
   	
   	printf("resamplemesh: Finished!\n");
   	
    return 0;
    
}

