/////////////////////////////////////////////////////////////////////////////
// complexitymetrics.cpp - Used to compute different terrain complexity metrics
// (rugosity and fractal dimension) over a range of scales
//

#include "complexitymetrics.hpp"

#include "simplematrix.hpp"
#include "coordtransforms.hpp"
#include "stats.hpp"

#include <gsl/gsl_multifit.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_blas.h>

#include <vector>
#include <sstream>
#include <fstream>
#include <iostream>

#include "tinyply.hpp"
using namespace tinyply;

#define BUFFERSIZE 2048

#include <time.h>

// Vertex - Simple vertex struct
typedef struct Vertex {
  float x,y,z;  
} Vertex;

// Face - Simple face structure
typedef struct Face {
	unsigned int nverts;
	int *verts;
} Face;

// FreePoints3D - Clean up points
void FreePoints3D(Points3D *points3d)
{
    if (points3d->n > 0) {
        free(points3d->X);
        free(points3d->Y);
        free(points3d->Z);
    }
}

// FreeTriData - Clean up tridata
void FreeTriData(TriData *tridata) {
    if (tridata->n > 0) {
        free(tridata->first);
        free(tridata->second);
        free(tridata->third);
    }
}

// GetPointsfromSinglePly - function used to get vertex and face data from ply
int GetPointsfromSinglePly(const std::string & filename, Points3D *points3d, TriData *tridata) 
{
	
	try
	{
		// Read the file and create a std::istringstream suitable
		// for the lib -- tinyply does not perform any file i/o.
		std::ifstream ss(filename, std::ios::binary);

		// Parse the ASCII header fields
		PlyFile file(ss);

		//for (auto e : file.get_elements())
		//{ }

		// Define containers to hold the extracted data. The type must match
		// the property type given in the header. Tinyply will interally allocate the
		// the appropriate amount of memory.
		std::vector<float> verts;
		std::vector<uint32_t> faces;

		uint32_t vertexCount, faceCount;
		vertexCount = faceCount = 0;

		vertexCount = file.request_properties_from_element("vertex", { "x", "y", "z" }, verts);
		faceCount = file.request_properties_from_element("face", { "vertex_indices" }, faces, 3);
		
		if ( (vertexCount == 0) && (faceCount == 0) ) {
			printf("Invalid play file\n");
			return -1;
		}
		else if ( (vertexCount == 0) || (faceCount == 0) ) {
			printf("ply file does not contain appropriate mesh geometry (nvertex: %d, nface: %d)\n",vertexCount,faceCount);
			return -1;
		}
		
		// Now populate the vectors...
		file.read(ss);

		// Good place to put a breakpoint!
		//std::cout << "\tRead " << verts.size() << " total vertices (" << vertexCount << " properties)." << std::endl;
		//std::cout << "\tRead " << faces.size() << " total faces (triangles) (" << faceCount << " properties)." << std::endl;
		
		// Copy data into point/tri data structures
		points3d->n = vertexCount;
		points3d->X = (double*)malloc(points3d->n*sizeof(double));
		points3d->Y = (double*)malloc(points3d->n*sizeof(double));
		points3d->Z = (double*)malloc(points3d->n*sizeof(double));
		for (int i = 0; i < vertexCount; i++) {
			points3d->X[i] = verts[3*i];
			points3d->Y[i] = verts[3*i+1];
			points3d->Z[i] = verts[3*i+2];
		}
		tridata->n = faceCount;
		tridata->first = (int*)malloc(tridata->n*sizeof(int));
		tridata->second = (int*)malloc(tridata->n*sizeof(int));
		tridata->third = (int*)malloc(tridata->n*sizeof(int));
		for (int i = 0; i < faceCount; i++) {
			tridata->first[i] = faces[3*i];
			tridata->second[i] = faces[3*i+1];
			tridata->third[i] = faces[3*i+2];
		}
		
	}

	catch (const std::exception & e)
	{
		std::cerr << "Caught exception: " << e.what() << std::endl;
		return -1;
	}
	
	return 0;
	
}
	
// CreateTotalTriPly - Creates ply file of triangulated surface
int CreateTotalTriPly(const std::string & filename, Points3D *points3d, TriData *tridata) 
{
	
	// Copy vertex/triangle data to vectors
	std::vector<float> verts(3*points3d->n);
	std::vector<int32_t> vertexIndicies(3*tridata->n);
	for (int i = 0; i < points3d->n; i++) {
		verts[3*i] = points3d->X[i];
		verts[3*i+1] = points3d->Y[i];
		verts[3*i+2] = points3d->Z[i];
	}
	for (int i = 0; i < tridata->n; i++) {
		vertexIndicies[3*i] = tridata->third[i];
		vertexIndicies[3*i+1] = tridata->second[i];
		vertexIndicies[3*i+2] = tridata->first[i];
	}
	
	// write to file
	std::filebuf fb;
	fb.open(filename, std::ios::out | std::ios::binary);
	std::ostream outputStream(&fb);

	PlyFile myFile;

	myFile.add_properties_to_element("vertex", { "x", "y", "z" }, verts);

	// List property types must also be created with a count and type of the list (data property type
	// is automatically inferred from the type of the vector argument). 
	myFile.add_properties_to_element("face", { "vertex_indices" }, vertexIndicies, 3, PlyProperty::Type::UINT8);

	myFile.comments.push_back("generated by tinyply");
	myFile.write(outputStream, true);

	fb.close();
	
	return 0;
	
}

int nextind(int *clipped, int ind, int n) {
    int j = ind+1;
    for (int i = 0; i < (n-1); i++) {
        if (j >= n) {
            j = 0;
        }
        if (clipped[j] == 0) {
            return(j);
        }
        j++;
    }
    return(-1);
}

int intriangle(double x, double y, double x0, double y0, double x1, double y1, double x2, double y2) 
{

	double a1 = (y1 - y2);
	double b1 = (x2 - x1);
	double c1 = -a1*x2 - b1*y2;
	double a2 = (y2 - y0);
	double b2 = (x0 - x2);
	double c2 = -a2*x2 - b2*y2;
	double d = (y1 - y2)*(x0 - x2) + (x2 - x1)*(y0 - y2);
	
	if (d == 0.0) { // not a proper triangle, skip
		return(0);
	}
	
	double w0 = (a1*x + b1*y + c1)/d;
	double w1 = (a2*x + b2*y + c2)/d;
	double w2 = 1.0 - w0 - w1;
	//printf("W: [%f %f %f]\n",w0,w1,w2);
	if ( (w0 >= 0) && (w0 <= 1) && (w1 >= 0) && (w1 <= 1) && (w2 >= 0) && (w2 <= 1) ) {
	    return(1);
	}
	else {
	    return(0);
	}
	
}

// ReadResolutions - used to import resolutions file to compute metrics at
int ReadResolutions(char *filepath, Metrics *metrics)
{
	
	FILE *file;
	char line[2048];
	
	// Open file
	if (!(file = fopen(filepath, "r" ))) {
		printf("file open error (scales.txt) ...\n");
		return -1;
	}
	
	// Count files
	metrics->nresolutions = 0;
	while (fgets(line,BUFFERSIZE,file) != NULL) {
		metrics->nresolutions++;
	}
	
	// close file
	if (fclose(file)) {
		printf("file close error ...\n");
		return -1;
	}
	
	// Open file
	if (!(file = fopen(filepath, "r" ))) {
		printf("file open error (scales.txt) ...\n");
		return -1;
	}
	
	// Read data
	metrics->resolutions = (double*)malloc(metrics->nresolutions*sizeof(double));
	for (int i = 0; i < metrics->nresolutions; i++) {
	    fgets(line,BUFFERSIZE,file);
	    sscanf(line,"%lf",&(metrics->resolutions[i]));
	}
	
	// close file
	if (fclose(file)) {
		printf("file close error ...\n");
		return -1;
	}	

	return 0;
	
}

// compute_planefit - Computes a plane of best fit to the data in a set of 3D points
// and returns the transformation parameters to rotate to a horizontal plane
void compute_planefit(Points3D *points3d, double *R, int b_return_points, Points3D *points3d_fitted)
{
    
    gsl_matrix *H, *cov;
    gsl_vector *z, *x;
    double chisq;
    
    double xmax, xmin, ymax, ymin;
    double i_plane[3], j_plane[3], j_dir[3], k_plane[3];
    double dist;
    double unitmat[3];
	double P[3], P2[3];
	
	// Fit ground plane to 3D points
	H = gsl_matrix_alloc(points3d->n,3);
	cov = gsl_matrix_alloc(3,3);
    z = gsl_vector_alloc(points3d->n);
    x = gsl_vector_alloc(3);
    for (int i = 0; i < points3d->n; i++) {
    	gsl_matrix_set (H, i, 0, -points3d->X[i]);
        gsl_matrix_set (H, i, 1, -points3d->Y[i]);
        gsl_matrix_set (H, i, 2, -1.0);   
        gsl_vector_set (z, i, points3d->Z[i]);
    }
    gsl_multifit_linear_workspace *work = gsl_multifit_linear_alloc(points3d->n,3);
	gsl_multifit_linear(H, z, x, cov, &chisq, work);
    //printf("x: [%f %f %f]\n",gsl_vector_get(x,0),gsl_vector_get(x,1),gsl_vector_get(x,2));
    
    xmax = max(points3d->X,points3d->n);
    xmin = min(points3d->X,points3d->n);
    ymax = max(points3d->Y,points3d->n);
    ymin = min(points3d->Y,points3d->n);
    
    i_plane[0] = xmax-xmin;
    i_plane[1] = 0;
    i_plane[2] = -gsl_vector_get(x,0)*xmax - gsl_vector_get(x,2) - (-gsl_vector_get(x,0)*xmin - gsl_vector_get(x,2));
    dist = sqrt(i_plane[0]*i_plane[0] + i_plane[1]*i_plane[1] + i_plane[2]*i_plane[2]);
    i_plane[0] = i_plane[0]/dist;
    i_plane[1] = i_plane[1]/dist;
    i_plane[2] = i_plane[2]/dist;
    
    j_dir[0] = 0;
    j_dir[1] = ymax-ymin;
    j_dir[2] = -gsl_vector_get(x,1)*ymax - gsl_vector_get(x,2) - (-gsl_vector_get(x,1)*ymin - gsl_vector_get(x,2));
    dist = sqrt(j_dir[0]*j_dir[0] + j_dir[1]*j_dir[1] + j_dir[2]*j_dir[2]);
    j_dir[0] = j_dir[0]/dist;
    j_dir[1] = j_dir[1]/dist;
    j_dir[2] = j_dir[2]/dist;
    
    cross3x3(i_plane,j_dir,k_plane);
    cross3x3(k_plane,i_plane,j_plane);
    
    unitmat[0] = 1.0;	unitmat[1] = 0.0;	unitmat[2] = 0.0;
    R[0] = dot3x3(i_plane, unitmat);
    R[3] = dot3x3(j_plane, unitmat);
    R[6] = dot3x3(k_plane, unitmat);
    
    unitmat[0] = 0.0;	unitmat[1] = 1.0;	unitmat[2] = 0.0;
    R[1] = dot3x3(i_plane, unitmat);
    R[4] = dot3x3(j_plane, unitmat);
    R[7] = dot3x3(k_plane, unitmat);
    
    unitmat[0] = 0.0;	unitmat[1] = 0.0;	unitmat[2] = 1.0;
    R[2] = dot3x3(i_plane, unitmat);
    R[5] = dot3x3(j_plane, unitmat);
    R[8] = dot3x3(k_plane, unitmat);
    
    // Create new set of trasnformed points
    if (b_return_points == 1) {
		points3d_fitted->n = points3d->n;
		points3d_fitted->X = (double*)malloc(points3d_fitted->n*sizeof(double));
		points3d_fitted->Y = (double*)malloc(points3d_fitted->n*sizeof(double));
		points3d_fitted->Z = (double*)malloc(points3d_fitted->n*sizeof(double));
		for (int i = 0; i < points3d->n; i++) {
			P[0] = points3d->X[i];
			P[1] = points3d->Y[i];
			P[2] = points3d->Z[i];
			MatVectorMult3x3(R, P, P2);
			points3d_fitted->X[i] = P2[0];
			points3d_fitted->Y[i] = P2[1];
			points3d_fitted->Z[i] = P2[2];
		}
    }
    
	// Clean up
	gsl_multifit_linear_free(work);
	gsl_matrix_free(H);
	gsl_matrix_free(cov);
    gsl_vector_free(z);
    gsl_vector_free(x);
   
}

void InitGridMap(GridMap *gridmap, Points3D *points3d, double grid_res, double xfrac_off, double yfrac_off)
{
    gridmap->grid_res = grid_res;
    
    double xmin = min(points3d->X,points3d->n);
    double xmax = max(points3d->X,points3d->n);
    double ymin = min(points3d->Y,points3d->n);
    double ymax = max(points3d->Y,points3d->n);
    
    //printf("%.4f %.4f %.4f %.4f\n",xmin,xmax,ymin,ymax);
    
    gridmap->xoffset = xmin + grid_res*xfrac_off;
    gridmap->yoffset = ymin + grid_res*yfrac_off;
    
    gridmap->nx = ceil((xmax-xmin)/grid_res) + 1;
    gridmap->ny = ceil((ymax-ymin)/grid_res) + 1;
    
    gridmap->grid_heights = (double**)malloc(gridmap->nx*sizeof(double*));
    gridmap->grid_occ = (int**)malloc(gridmap->nx*sizeof(int*));
    for (int i = 0; i < gridmap->nx; i++) {
        gridmap->grid_heights[i] = (double*)malloc(gridmap->ny*sizeof(double));
        gridmap->grid_occ[i] = (int*)malloc(gridmap->ny*sizeof(int));
        for (int j = 0; j < gridmap->ny; j++) {
            gridmap->grid_heights[i][j] = 0.0;
            gridmap->grid_occ[i][j] = 0;
        }
    }
    
}

void FreeGridMap(GridMap *gridmap)
{
    for (int i = 0; i < gridmap->nx; i++) {
        free(gridmap->grid_heights[i]);
    }
    free(gridmap->grid_heights);
    for (int i = 0; i < gridmap->nx; i++) {
        free(gridmap->grid_occ[i]);
    }
    free(gridmap->grid_occ);
}

// InterpTritoGridMap - Function used to rasterise interpolated values into a triangle
void InterpTritoGridMap(double x0a, double y0a, double x1a, double y1a, double x2a, double y2a,
	double val0, double val1, double val2, GridMap *gridmap, int label) {
	
	double x0, x1, x2, y0, y1, y2;
	double w0, w1, w2;
	double w0a, w1a, w2a, w0b, w1b, w2b, w0c, w1c, w2c, w0d, w1d, w2d;
	double xvals[3], yvals[3];
	double xmin, xmax, ymin, ymax;
	int i2, j2;
	
	int Nsamp = 5;
	double sampinc = 1.0/((double)Nsamp);
	
	x0 = (x0a-gridmap->xoffset)/gridmap->grid_res;
	x1 = (x1a-gridmap->xoffset)/gridmap->grid_res;
	x2 = (x2a-gridmap->xoffset)/gridmap->grid_res;
	y0 = (y0a-gridmap->yoffset)/gridmap->grid_res;
	y1 = (y1a-gridmap->yoffset)/gridmap->grid_res;
	y2 = (y2a-gridmap->yoffset)/gridmap->grid_res;
	
	xvals[0] = x0;
	xvals[1] = x1;
	xvals[2] = x2;
	yvals[0] = y0;
	yvals[1] = y1;
	yvals[2] = y2;
	xmin = min(xvals,3);
	xmax = max(xvals,3);
	ymin = min(yvals,3);
	ymax = max(yvals,3);
	
	// Compute barycentric coordinates
	double a1 = (y1 - y2);
	double b1 = (x2 - x1);
	double c1 = -a1*x2 - b1*y2;
	double a2 = (y2 - y0);
	double b2 = (x0 - x2);
	double c2 = -a2*x2 - b2*y2;
	double d = (y1 - y2)*(x0 - x2) + (x2 - x1)*(y0 - y2);
	
	if (d == 0.0) { // not a proper triangle, skip
		return;
	}
	
	// loop through potential grid values
	//for (int i = (int)ceil(xmin); i <= (int)floor(xmax); i++) {
	//	for (int j = (int)ceil(ymin); j <= (int)floor(ymax); j++) {
	for (int i = (int)floor(xmin); i <= (int)floor(xmax); i++) {
		for (int j = (int)floor(ymin); j <= (int)floor(ymax); j++) {
			
			i2 = i;
			j2 = j;
			if (i2 < 0) {
				i2 = 0;
			}
			if (i2 >= gridmap->nx) {
				i2 = gridmap->nx-1;
			}
			if (j2 < 0) {
				j2 = 0;
			}
			if (j2 >= gridmap->ny) {
				j2 = gridmap->ny-1;
			}
			
			// Update rendering mechanism for proper averaging
			if (label >= 0) {
				w0 = (a1*((double)i) + b1*((double)j) + c1)/d;
				w1 = (a2*((double)i) + b2*((double)j) + c2)/d;
				w2 = 1.0 - w0 - w1;
				if ( (w0 >= 0) && (w0 <= 1) && (w1 >= 0) && (w1 <= 1) && (w2 >= 0) && (w2 <= 1) ) {
					gridmap->grid_occ[i2][j2] = label;
				}
			}
			else {
				
				// check first for completely enclosed grid
				w0a = (a1*((double)(i-0.5)) + b1*((double)(j-0.5)) + c1)/d;
				w1a = (a2*((double)(i-0.5)) + b2*((double)(j-0.5)) + c2)/d;
				w2a = 1.0 - w0a - w1a;
				w0b = (a1*((double)(i+0.5)) + b1*((double)(j-0.5)) + c1)/d;
				w1b = (a2*((double)(i+0.5)) + b2*((double)(j-0.5)) + c2)/d;
				w2b = 1.0 - w0b - w1b;
				w0c = (a1*((double)(i+0.5)) + b1*((double)(j+0.5)) + c1)/d;
				w1c = (a2*((double)(i+0.5)) + b2*((double)(j+0.5)) + c2)/d;
				w2c = 1.0 - w0c - w1c;
				w0d = (a1*((double)(i-0.5)) + b1*((double)(j+0.5)) + c1)/d;
				w1d = (a2*((double)(i-0.5)) + b2*((double)(j+0.5)) + c2)/d;
				w2d = 1.0 - w0d - w1d;
				if ( (w0a >= 0) && (w0a <= 1) && (w1a >= 0) && (w1a <= 1) && (w2a >= 0) && (w2a <= 1) &&
				(w0b >= 0) && (w0b <= 1) && (w1b >= 0) && (w1b <= 1) && (w2b >= 0) && (w2b <= 1) &&
				(w0c >= 0) && (w0c <= 1) && (w1c >= 0) && (w1c <= 1) && (w2c >= 0) && (w2c <= 1) &&
				(w0d >= 0) && (w0d <= 1) && (w1d >= 0) && (w1d <= 1) && (w2d >= 0) && (w2d <= 1) ) {
					w0 = (a1*((double)i) + b1*((double)j) + c1)/d;
					w1 = (a2*((double)i) + b2*((double)j) + c2)/d;
					w2 = 1.0 - w0 - w1;
					double z = w0*val0 + w1*val1 + w2*val2;
					gridmap->grid_heights[i2][j2] = gridmap->grid_heights[i2][j2] + z;
					gridmap->grid_occ[i2][j2]++;
				}
				else {	// Need to do it the hard way: sample subsections of grid
					for (int ii = 0; ii < Nsamp; ii++) {
						for (int jj = 0; jj < Nsamp; jj++) {
							w0 = (a1*((double)(i-0.4+sampinc*ii)) + b1*((double)(j-0.4+sampinc*jj)) + c1)/d;
							w1 = (a2*((double)(i-0.4+sampinc*ii)) + b2*((double)(j-0.4+sampinc*jj)) + c2)/d;
							w2 = 1.0 - w0 - w1;
							if ( (w0 >= 0) && (w0 <= 1) && (w1 >= 0) && (w1 <= 1) && (w2 >= 0) && (w2 <= 1) ) {
								double z = w0*val0 + w1*val1 + w2*val2;
								gridmap->grid_heights[i2][j2] = gridmap->grid_heights[i2][j2] + z;
								gridmap->grid_occ[i2][j2]++;
								//if (z > 0.001) {
								//	printf("tri: %d, ij: %d %d, ii/jj: %d %d, z: %.2f, n: %d\n",0,i,j,ii,jj,z,gridmap->grid_occ[i2][j2]);
								//}
							}
						}
					}
				}
			}
			
			
			
			
			/*
			// check if in bounds
			w0 = (a1*((double)i) + b1*((double)j) + c1)/d;
			w1 = (a2*((double)i) + b2*((double)j) + c2)/d;
			w2 = 1.0 - w0 - w1;
			if ( (w0 >= 0) && (w0 <= 1) && (w1 >= 0) && (w1 <= 1) && (w2 >= 0) && (w2 <= 1) ) {
				if (label == -1) {
					double z = w0*val0 + w1*val1 + w2*val2;
					gridmap->grid_heights[i2][j2] = gridmap->grid_heights[i2][j2] + z;
					gridmap->grid_occ[i2][j2]++;
			    }
			    else {
			    	gridmap->grid_occ[i2][j2] = label;
			    }
			}
			*/
			
			
			
			
		}
	}
	
}

// CreateSurffromGrid - Used to create and point cloud and triangles from a grid DEM
void CreateSurffromGrid(GridMap *gridmap, Points3D *points3d, TriData *tridata) 
{
    
    // Count points and faces
    int npoints = 0;
    for (int i = 0; i < gridmap->nx; i++) {
        for (int j = 0; j < gridmap->ny; j++) {
            if (gridmap->grid_occ[i][j] >= 1) {
                npoints++;
            }
        }
    }
    int nfaces = 0;
    for (int i = 0; i < (gridmap->nx-1); i++) {
        for (int j = 0; j < (gridmap->ny-1); j++) {
            if ( (gridmap->grid_occ[i][j] >= 1) &&
               (gridmap->grid_occ[i+1][j] >= 1) &&
               (gridmap->grid_occ[i][j+1] >= 1) ) {
                nfaces++;
            }
            if ( (gridmap->grid_occ[i+1][j+1] >= 1) &&
               (gridmap->grid_occ[i+1][j] >= 1) &&
               (gridmap->grid_occ[i][j+1] >= 1) ) {
                nfaces++;
            }
        }
    }
    //printf("pred: %d %d\n",npoints,nfaces);
    
    // Initialise points and faces
    points3d->n = npoints;
    points3d->nmem = points3d->n;
    points3d->X = (double*)malloc(points3d->n*sizeof(double));
    points3d->Y = (double*)malloc(points3d->n*sizeof(double));
    points3d->Z = (double*)malloc(points3d->n*sizeof(double));
    
    tridata->n = nfaces;
    tridata->first = (int*)malloc(tridata->n*sizeof(int));
    tridata->second = (int*)malloc(tridata->n*sizeof(int));
    tridata->third = (int*)malloc(tridata->n*sizeof(int));
    
    // Initialise data structure to track point index
    int **grid_ref = (int**)malloc(gridmap->nx*sizeof(int*));
    for (int i = 0; i < gridmap->nx; i++) {
        grid_ref[i] = (int*)malloc(gridmap->ny*sizeof(int));
        for (int j = 0; j < gridmap->ny; j++) {
            grid_ref[i][j] = -1;
        }
    }
    
    // Grab points and generate triangles
    npoints = 0;
    for (int i = 0; i < gridmap->nx; i++) {
        for (int j = 0; j < gridmap->ny; j++) {
            if (gridmap->grid_occ[i][j] >= 1) {
                points3d->X[npoints] = gridmap->grid_res*(double)i + gridmap->xoffset;
                points3d->Y[npoints] = gridmap->grid_res*(double)j + gridmap->yoffset;
                points3d->Z[npoints] = gridmap->grid_heights[i][j];
                grid_ref[i][j] = npoints;
                npoints++;
            }
        }
    }
    nfaces = 0;
    for (int i = 0; i < (gridmap->nx-1); i++) {
        for (int j = 0; j < (gridmap->ny-1); j++) {
            if ( (gridmap->grid_occ[i][j] >= 1) &&
               (gridmap->grid_occ[i+1][j] >= 1) &&
               (gridmap->grid_occ[i][j+1] >= 1) ) {
                //tridata->first[nfaces] = grid_ref[i][j];
                //tridata->second[nfaces] = grid_ref[i+1][j];
                //tridata->third[nfaces] = grid_ref[i][j+1];
                tridata->first[nfaces] = grid_ref[i][j];
                tridata->second[nfaces] = grid_ref[i][j+1];
                tridata->third[nfaces] = grid_ref[i+1][j];
                nfaces++;
            }
            if ( (gridmap->grid_occ[i+1][j+1] >= 1) &&
               (gridmap->grid_occ[i+1][j] >= 1) &&
               (gridmap->grid_occ[i][j+1] >= 1) ) {
                //tridata->first[nfaces] = grid_ref[i+1][j];
                //tridata->second[nfaces] = grid_ref[i+1][j+1];
                //tridata->third[nfaces] = grid_ref[i][j+1];
                tridata->first[nfaces] = grid_ref[i+1][j];
                tridata->second[nfaces] = grid_ref[i][j+1];
                tridata->third[nfaces] = grid_ref[i+1][j+1];
                nfaces++;
            }
        }
    }
    
    //printf("CreateSurffromGrid Check: points: (%d/%d), tri: (%d/%d)\n",
    //    npoints,points3d->n,nfaces,tridata->n);
    
}

// Resamplegridtri - Used to resample a 2.5D triangulated surface model to a specified grid resolution
void Resample_GridTri(Points3D *points3d, TriData *tridata, double sample_size,
    Points3D *points3d_resampled, TriData *tridata_resampled, double xfrac_off, double yfrac_off)
{
    
    GridMap gridmap;
    
    // Setup grid data
    InitGridMap(&gridmap, points3d, sample_size, xfrac_off, yfrac_off);
    //printf("Grid Map: size: [%dx%d], res: %f\n",gridmap.nx,gridmap.ny,gridmap.grid_res);
    
    // Cycle through triangles, raster into grid
    for (int i = 0; i < tridata->n; i++) {
    	InterpTritoGridMap(points3d->X[tridata->first[i]], points3d->Y[tridata->first[i]], 
    		points3d->X[tridata->second[i]], points3d->Y[tridata->second[i]], 
    		points3d->X[tridata->third[i]], points3d->Y[tridata->third[i]], 
			points3d->Z[tridata->first[i]], points3d->Z[tridata->second[i]], points3d->Z[tridata->third[i]], 
			&gridmap, -1);
    }
    
    // average heights
    for (int i = 0; i < gridmap.nx; i++) {
        for (int j = 0; j < gridmap.ny; j++) {
            if (gridmap.grid_occ[i][j] > 0) {
                gridmap.grid_heights[i][j] = gridmap.grid_heights[i][j]/gridmap.grid_occ[i][j];
                gridmap.grid_occ[i][j] = 1;
            }
        }
    }
    
    // Create point cloud and triangulation from grid
    CreateSurffromGrid(&gridmap, points3d_resampled, tridata_resampled);
    
    // Clean up
    FreeGridMap(&gridmap);
    
}

// GetTriListWindow_Square
int GetTriListWindow_Square(Points3D *points3d_fitted, TriData *tridata, int *trilist, double centx, double centy, double wsize)
{  
    int tcount = 0;
    double bounds[4];
    bounds[0] = centx - wsize/2.0;
    bounds[1] = centx + wsize/2.0;
    bounds[2] = centy - wsize/2.0;
    bounds[3] = centy + wsize/2.0;
    for (int j = 0; j < tridata->n; j++) {
        double x0 = points3d_fitted->X[tridata->first[j]];
        double y0 = points3d_fitted->Y[tridata->first[j]];
        double x1 = points3d_fitted->X[tridata->second[j]];
        double y1 = points3d_fitted->Y[tridata->second[j]];
        double x2 = points3d_fitted->X[tridata->third[j]];
        double y2 = points3d_fitted->Y[tridata->third[j]];
        //printf("%f %f %f %f %f %f\n",x0,y0,x1,y1,x2,y2);
        //printf("%f %f %f %f\n",bounds[0],bounds[1],bounds[2],bounds[3]);
        if ( (x0 >= bounds[0]) && (x0 <= bounds[1]) && (y0 >= bounds[2]) && (y0 <= bounds[3]) &&
            (x1 >= bounds[0]) && (x1 <= bounds[1]) && (y1 >= bounds[2]) && (y1 <= bounds[3]) &&
            (x2 >= bounds[0]) && (x2 <= bounds[1]) && (y2 >= bounds[2]) && (y2 <= bounds[3]) ) {
            trilist[tcount] = j;
            tcount++;
        }
    }
    return(tcount);
}

// Calculate area-based metrics
void calc_area_metrics(Points3D *points3d_fitted, TriData *tridata, int *trilist, int ntri,
	int *point_index, Metrics *metrics, int quad_ind, int res_ind, GridMap *areagridmap, 
	int planeofbestfit)
{
   	double area_surface = 0;
   	double area_projected = 0;
   	
   	double FeatPos1t[3], FeatPos2t[3], FeatPos3t[3];
    double FeatPos1h[3], FeatPos2h[3], FeatPos3h[3];
   	
   	// Get total surface area
   	if (planeofbestfit == 0) { // only grab total area for vertical based calcs
		for (int jt = 0; jt < ntri; jt++) {
		
			int j = trilist[jt];
	
			// Get triangle coordinates
			FeatPos1t[0] = points3d_fitted->X[point_index[tridata->first[j]]];
			FeatPos1t[1] = points3d_fitted->Y[point_index[tridata->first[j]]];
			FeatPos1t[2] = points3d_fitted->Z[point_index[tridata->first[j]]];
		
			FeatPos2t[0] = points3d_fitted->X[point_index[tridata->second[j]]];
			FeatPos2t[1] = points3d_fitted->Y[point_index[tridata->second[j]]];
			FeatPos2t[2] = points3d_fitted->Z[point_index[tridata->second[j]]];
		
			FeatPos3t[0] = points3d_fitted->X[point_index[tridata->third[j]]];
			FeatPos3t[1] = points3d_fitted->Y[point_index[tridata->third[j]]];
			FeatPos3t[2] = points3d_fitted->Z[point_index[tridata->third[j]]];
		
			// Get areas
			double lside1 = normdiff3(FeatPos1t,FeatPos2t);
			double lside2 = normdiff3(FeatPos2t,FeatPos3t);
			double lside3 = normdiff3(FeatPos3t,FeatPos1t);
			double pl = (lside1 + lside2 + lside3)/2;
			double check_val = pl*(pl-lside1)*(pl-lside2)*(pl-lside3);
			if (check_val > 0.0) {
				area_surface = area_surface + sqrt(check_val);
			}
		
		}
   	}
   	
   	// Rasterise to estimate projected 2D area
   	int label = quad_ind + (metrics->nquad+1)*res_ind + (metrics->nquad+1+metrics->nresolutions+1)*planeofbestfit;
   	for (int jt = 0; jt < ntri; jt++) {
   	    
   	    //printf("jt: %d of %d\n",jt,ntri);
   	    
   	    int j = trilist[jt];
   		
   		//printf("j: %d\n",j);
   		
   		//printf("%d %d %d of %d\n",tridata->first[j],tridata->second[j],tridata->third[j],points3d_fitted->n);
   		//printf("%d %d %d of %d\n",point_index[tridata->first[j]],point_index[tridata->second[j]],
   		//	point_index[tridata->third[j]],points3d_fitted->n);
   		
   	    // Get triangle coordinates		
		FeatPos1h[0] = points3d_fitted->X[point_index[tridata->first[j]]];
		FeatPos1h[1] = points3d_fitted->Y[point_index[tridata->first[j]]];
		FeatPos1h[2] = points3d_fitted->Z[point_index[tridata->first[j]]];
		
		FeatPos2h[0] = points3d_fitted->X[point_index[tridata->second[j]]];
		FeatPos2h[1] = points3d_fitted->Y[point_index[tridata->second[j]]];
		FeatPos2h[2] = points3d_fitted->Z[point_index[tridata->second[j]]];
		
		FeatPos3h[0] = points3d_fitted->X[point_index[tridata->third[j]]];
		FeatPos3h[1] = points3d_fitted->Y[point_index[tridata->third[j]]];
		FeatPos3h[2] = points3d_fitted->Z[point_index[tridata->third[j]]];
		
		//printf("%f %f %f %f %f %f\n",FeatPos1h[0], FeatPos1h[1], FeatPos2h[0], FeatPos2h[1], FeatPos3h[0], FeatPos3h[1]);
		
		InterpTritoGridMap(FeatPos1h[0], FeatPos1h[1], FeatPos2h[0], FeatPos2h[1], FeatPos3h[0], FeatPos3h[1],
			0.0, 0.0, 0.0, areagridmap, label);
		
		//printf("fin\n");
	}
	
	int occ_count = 0;
	for (int i = 0; i < areagridmap->nx; i++) {
        for (int j = 0; j < areagridmap->ny; j++) {
            if (areagridmap->grid_occ[i][j] == label) {
            	occ_count++;
            }
        }
    }
    
   	//area_projected = (occ_count/((float)areagridmap->nx*areagridmap->ny))*(areagridmap->nx*areagridmap->ny*areagridmap->grid_res*areagridmap->grid_res);
   	area_projected = occ_count*areagridmap->grid_res*areagridmap->grid_res;
   	
   	if (planeofbestfit == 0) {
		metrics->area2D[quad_ind][res_ind] = area_projected;
		metrics->area3D[quad_ind][res_ind] = area_surface;
		if (area_projected == 0) {
			metrics->rugosity[quad_ind][res_ind] = -1;
		}
		else {
			metrics->rugosity[quad_ind][res_ind] = area_surface/area_projected;
		}
	}
	else {
		metrics->area2Dplane[quad_ind][res_ind] = area_projected;
		if (area_projected == 0) {
			metrics->rugosityplane[quad_ind][res_ind] = -1;
		}
		else {
			metrics->rugosityplane[quad_ind][res_ind] = metrics->area3D[quad_ind][res_ind]/area_projected;
		}
	}
   	
}

// Calculate metrics based on relief (height)
void calc_relief_metrics(Points3D *points3d_fitted, TriData *tridata, int *trilist, int ntri,
	Metrics *metrics, int quad_ind, int res_ind, double *quadratface_heights)
{
   	
   	// get heights
   	for (int jt = 0; jt < ntri; jt++) {
   	    int j = trilist[jt];
		double z1 = points3d_fitted->Z[tridata->first[j]];
		double z2 = points3d_fitted->Z[tridata->second[j]];
		double z3 = points3d_fitted->Z[tridata->third[j]];
		quadratface_heights[jt] = (z1+z2+z3)/3.0;
   	}
   	
   	if (ntri > 0) {
		double max_height = max(quadratface_heights,ntri);
		double min_height = min(quadratface_heights,ntri);
		metrics->height_range[quad_ind][res_ind] = max_height - min_height;
		metrics->height_std[quad_ind][res_ind] = sqrt(var(quadratface_heights,ntri));
		if (res_ind == 0) {
			metrics->quad_mean_h[quad_ind] = mean(quadratface_heights,ntri);
		}
	}
	else {
		metrics->height_range[quad_ind][res_ind] = 0.0;
		metrics->height_std[quad_ind][res_ind] = 0.0;
		if (res_ind == 0) {
			metrics->quad_mean_h[quad_ind] = 0.0;
		}
	}
   	
}

// Calculate metrics based on vertical angle (slope)
void calc_vertangle_metrics(Points3D *points3d_fitted, TriData *tridata, int *trilist, int ntri,
	Metrics *metrics, int quad_ind, double *quadratface_slopes)
{
   	
   	double FeatPos1[3], FeatPos2[3], FeatPos3[3];
   	double N[3];
   	double total_area = 0;
   	
   	// Initialise zeros in bins
   	for (int i = 0; i < 18; i++) {
   		metrics->vertangle_bins[i][quad_ind] = 0.0;
   	}
   	
   	// get slopes
   	for (int jt = 0; jt < ntri; jt++) {
   	    int j = trilist[jt];
   	    
   	    // Get triangle coordinates
   	    FeatPos1[0] = points3d_fitted->X[tridata->first[j]];
		FeatPos1[1] = points3d_fitted->Y[tridata->first[j]];
		FeatPos1[2] = points3d_fitted->Z[tridata->first[j]];
		
		FeatPos2[0] = points3d_fitted->X[tridata->second[j]];
		FeatPos2[1] = points3d_fitted->Y[tridata->second[j]];
		FeatPos2[2] = points3d_fitted->Z[tridata->second[j]];
		
		FeatPos3[0] = points3d_fitted->X[tridata->third[j]];
		FeatPos3[1] = points3d_fitted->Y[tridata->third[j]];
		FeatPos3[2] = points3d_fitted->Z[tridata->third[j]];
   	    
   	    // TODO: will need to fix this method up to deal with different face orientations
   	    // properly
   	    
		// Get face normal data
    	N[0] = (FeatPos2[1] - FeatPos1[1])*(FeatPos3[2] - FeatPos1[2]) - 
    		(FeatPos2[2] - FeatPos1[2])*(FeatPos3[1] - FeatPos1[1]);
    	N[1] = (FeatPos2[2] - FeatPos1[2])*(FeatPos3[0] - FeatPos1[0]) - 
    		(FeatPos2[0] - FeatPos1[0])*(FeatPos3[2] - FeatPos1[2]);
    	N[2] = (FeatPos2[0] - FeatPos1[0])*(FeatPos3[1] - FeatPos1[1]) - 
    		(FeatPos2[1] - FeatPos1[1])*(FeatPos3[0] - FeatPos1[0]);
		
		double r = sqrt(N[0]*N[0] + N[1]*N[1] + N[2]*N[2]);
		if (r > 0.0) {
			N[0] = N[0]/r;
			N[1] = N[1]/r;
			N[2] = N[2]/r;
		}
		else {
			N[2] = 2.0; // force to set bad faces to zero slope for now
		}
		
		if (N[2] >= 1.0) {
			quadratface_slopes[jt] = 0.0;
		}
		else if (N[2] <= -1.0) {
			quadratface_slopes[jt] = 180.0;
		}
		else {
			quadratface_slopes[jt] = (180.0/M_PI)*acos(N[2]);
		}
		
		// Get 3D area (used for histogram weighting)
		double lside1 = normdiff3(FeatPos1,FeatPos2);
		double lside2 = normdiff3(FeatPos2,FeatPos3);
		double lside3 = normdiff3(FeatPos3,FeatPos1);
		double pl = (lside1 + lside2 + lside3)/2;
		double check_val = pl*(pl-lside1)*(pl-lside2)*(pl-lside3);
		double area_surface;
		if (check_val > 0.0) {
			area_surface = sqrt(check_val);
		}
		else {
			area_surface = 0.0;
		}
		
		int bin = (int)(quadratface_slopes[jt]/10.0);
		if (bin == 18) {
			bin = 17;
		}
		if ( (bin < 0) || (bin > 17) ) {
			printf("bin: %d\n",bin);
			printf("slope, N: %.4f, %.4f\n",quadratface_slopes[jt],N[2]);
			printf("V1: [%.4f,%.4f,%.4f]\n",FeatPos1[0],FeatPos1[1],FeatPos1[2]);
			printf("V2: [%.4f,%.4f,%.4f]\n",FeatPos2[0],FeatPos2[1],FeatPos2[2]);
			printf("V3: [%.4f,%.4f,%.4f]\n",FeatPos3[0],FeatPos3[1],FeatPos3[2]);
		}
		//printf("tri: %d of %d, bin: %d, quadind: %d, area_surf: %.4f\n",jt,ntri,bin,quad_ind,area_surface);
		//printf("exist area: %.4f\n",metrics->vertangle_bins[bin][quad_ind]);
		metrics->vertangle_bins[bin][quad_ind] += area_surface;
		//printf("done\n");
		total_area = total_area + area_surface;
		
   	}
   	
   	for (int i = 0; i < 18; i++) {
   		if (ntri > 0) {
   			metrics->vertangle_bins[i][quad_ind] = metrics->vertangle_bins[i][quad_ind]/total_area;
   		}
   		else {
   			metrics->vertangle_bins[i][quad_ind] = 0.0;
   		}
   	}
   	
   	if (ntri > 0) {
   		metrics->vertangle_mean[quad_ind] = mean(quadratface_slopes,ntri);
   		metrics->vertangle_std[quad_ind] = sqrt(var(quadratface_slopes,ntri));
   	}
   	else {
   		metrics->vertangle_mean[quad_ind] = 0.0;
   		metrics->vertangle_std[quad_ind] = 0.0;
   	}
   	
}

// WriteMetricstoCSV - output metric values to csv file
int WriteMetricstoCSV(char *filepath, Metrics *metrics, double *BoundCoords, char *mesh_name, double keep_area_thresh)
{
	
	FILE *file;
	
	// Open file
	if (!(file = fopen(filepath, "w" ))) {
		printf("file open error (metrics.csv) ...\n");
		return -1;
	}
	
	// workout size of whole mesh (max of bounding box width/height)
	double mesh_size;
	if ( (BoundCoords[1]-BoundCoords[0]) > (BoundCoords[3]-BoundCoords[2]) ) {
		mesh_size = BoundCoords[1]-BoundCoords[0];
	}
	else {
		mesh_size = BoundCoords[3]-BoundCoords[2];
	}
	
	// write header
	fprintf(file,"Mesh,Grid X,Grid Y,Center X,Center Y,Center Z,Quad Size,Num Faces,Num Verts,");
	fprintf(file,"Landscape Slope,Quad Fitted Slope,Vertical Angle Mean,Vertical Angle StdDev,");
	fprintf(file,"VertAngHist 0-10deg,VertAngHist 10-20deg,VertAngHist 20-30deg,VertAngHist 30-40deg,VertAngHist 40-50deg,VertAngHist 50-60deg,VertAngHist 60-70deg,VertAngHist 70-80deg,VertAngHist 80-90deg,");
	fprintf(file,"VertAngHist 90-100deg,VertAngHist 100-110deg,VertAngHist 110-120deg,VertAngHist 120-130deg,VertAngHist 130-140deg,VertAngHist 140-150deg,VertAngHist 150-160deg,VertAngHist 160-170deg,VertAngHist 170-180deg,");
	fprintf(file,"Quad Height Range,Quad Height StdDev,Quad 2D Area,Quad 3D Area,Quad Rugosity,Quad 2D Area (plane),Quad Rugosity (plane)");
	for (int i = 0; i < metrics->nresolutions; i++) {
		fprintf(file,",Quad Height Range (%.2f m),Quad Height StdDev (%.2f m),Quad 2D Area (%.2f m),Quad 3D Area (%.2f m),Quad Rugosity (%.2f m),Quad 2D Area (plane) (%.2f m),Quad Rugosity (plane)(%.2f m)",
			metrics->resolutions[i],metrics->resolutions[i],metrics->resolutions[i],metrics->resolutions[i],metrics->resolutions[i],metrics->resolutions[i],metrics->resolutions[i]);
	}
	fprintf(file,"\n");
	
	// write first row for whole mesh values
	fprintf(file,"%s,%d,%d,%.4f,%.4f,%.4f,%.4f,%d,%d,",mesh_name,
		metrics->quad_coordx[0],metrics->quad_coordy[0],metrics->quad_x[0],metrics->quad_y[0],
		metrics->quad_mean_h[0],mesh_size,metrics->numfaces[0],metrics->numverts[0]);
	fprintf(file,"%.1f,%.1f,%.1f,%.1f,",metrics->landscape_slope,
		metrics->fitted_slope[0],metrics->vertangle_mean[0],metrics->vertangle_std[0]);
	for (int i = 0; i < 18; i++) {
		fprintf(file,"%.3f,",metrics->vertangle_bins[i][0]);
	}
	fprintf(file,"%.4f,%.4f,%.4f,%.4f,%.6f,%.4f,%.4f",metrics->height_range[0][0],metrics->height_std[0][0],
		metrics->area2D[0][0],metrics->area3D[0][0],metrics->rugosity[0][0],metrics->area2Dplane[0][0],metrics->rugosityplane[0][0]);
	for (int i = 0; i < metrics->nresolutions; i++) {
		fprintf(file,",%.4f,%.4f,%.4f,%.4f,%.6f,%.4f,%.6f",metrics->height_range[0][i+1],metrics->height_std[0][i+1],
			metrics->area2D[0][i+1],metrics->area3D[0][i+1],metrics->rugosity[0][i+1],
			metrics->area2Dplane[0][i+1],metrics->rugosityplane[0][i+1]);
	}
	fprintf(file,"\n");
	
	// Cycle through and write quadrat data
	int good_quad_count = 0;
	for (int i = 0; i < metrics->nquad; i++) {
		
		// Check quad 2D area is sufficient to include quad
		if (metrics->area2D[i+1][0] >= (keep_area_thresh*metrics->quad_size*metrics->quad_size) ) {
			
			fprintf(file,"%s,%d,%d,%.4f,%.4f,%.4f,%.4f,%d,%d,",mesh_name,
				metrics->quad_coordx[i+1],metrics->quad_coordy[i+1],metrics->quad_x[i+1],metrics->quad_y[i+1],
				metrics->quad_mean_h[i+1],metrics->quad_size,metrics->numfaces[i+1],metrics->numverts[i+1]);
			fprintf(file,"%.1f,%.1f,%.1f,%.1f,",metrics->landscape_slope,
				metrics->fitted_slope[i+1],metrics->vertangle_mean[i+1],metrics->vertangle_std[i+1]);
			for (int j = 0; j < 18; j++) {
				fprintf(file,"%.3f,",metrics->vertangle_bins[j][i+1]);
			}
			fprintf(file,"%.4f,%.4f,%.4f,%.4f,%.6f,%.4f,%.6f",metrics->height_range[i+1][0],metrics->height_std[i+1][0],
				metrics->area2D[i+1][0],metrics->area3D[i+1][0],metrics->rugosity[i+1][0],
				metrics->area2Dplane[i+1][0],metrics->rugosityplane[i+1][0]);
			for (int j = 0; j < metrics->nresolutions; j++) {
				fprintf(file,",%.4f,%.4f,%.4f,%.4f,%.6f,%.4f,%.4f",metrics->height_range[i+1][j+1],metrics->height_std[i+1][j+1],
					metrics->area2D[i+1][j+1],metrics->area3D[i+1][j+1],metrics->rugosity[i+1][j+1],
					metrics->area2Dplane[i+1][j+1],metrics->rugosityplane[i+1][j+1]);
			}
			fprintf(file,"\n");
			
			good_quad_count++;
		}
		
	}
	
	// close file
	if (fclose(file)) {
		printf("file close error ...\n");
		return -1;
	}
	
	if (metrics->nquad > 0) {
		printf("complexitymetrics: Found %d quadrats in mesh\n",good_quad_count);
	}
	else {
		printf("complexitymetrics: Outputting whole mesh values only ...\n");
	}
	
	return 0;
	
}

/*// CreateQuadCoordsPLY - Create ply with lines outlining quadrat positions
int CreateQuadCoordsPLY(char *filepath, Metrics *metrics, double keep_area_thresh)
{
	
	FILE *file;
	
	// Open file
	if (!(file = fopen(filepath, "w" ))) {
		printf("file open error (metrics.csv) ...\n");
		return -1;
	}
	
	// write PLY header
	fprintf(file,"ply\n");
	fprintf(file,"format ascii 1.0\n");
	fprintf(file,"element vertex %d\n",4*metrics->nquad);
	fprintf(file,"property float x\n");
	fprintf(file,"property float y\n");
	fprintf(file,"property float z\n");
	fprintf(file,"property uchar red\n");
	fprintf(file,"property uchar green\n");
	fprintf(file,"property uchar blue\n");
	fprintf(file,"element face 0\n");
	fprintf(file,"property list uchar int vertex_indices\n");
	fprintf(file,"element edge %d\n",4*metrics->nquad);
	fprintf(file,"property int vertex1\n");
	fprintf(file,"property int vertex2\n");
	fprintf(file,"property uchar red\n");
	fprintf(file,"property uchar green\n");
	fprintf(file,"property uchar blue\n");
	fprintf(file,"end_header\n");
	
	double display_height = 1.0;
	
	// Create vertices
	for (int i = 0; i < metrics->nquad; i++) {
		if (metrics->area2D[i+1][0] >= (keep_area_thresh*metrics->quad_size*metrics->quad_size) ) {
			fprintf(file,"%.2f %.2f %.2f 0 255 0\n",
				metrics->quad_x[i+1]-(metrics->quad_size/2.0),metrics->quad_y[i+1]-(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
			fprintf(file,"%.2f %.2f %.2f 0 255 0\n",
				metrics->quad_x[i+1]+(metrics->quad_size/2.0),metrics->quad_y[i+1]-(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
			fprintf(file,"%.2f %.2f %.2f 0 255 0\n",
				metrics->quad_x[i+1]+(metrics->quad_size/2.0),metrics->quad_y[i+1]+(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
			fprintf(file,"%.2f %.2f %.2f 0 255 0\n",
				metrics->quad_x[i+1]-(metrics->quad_size/2.0),metrics->quad_y[i+1]+(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
		}
		else {
			fprintf(file,"%.2f %.2f %.2f 255 0 0\n",
				metrics->quad_x[i+1]-(metrics->quad_size/2.0),metrics->quad_y[i+1]-(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
			fprintf(file,"%.2f %.2f %.2f 255 0 0\n",
				metrics->quad_x[i+1]+(metrics->quad_size/2.0),metrics->quad_y[i+1]-(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
			fprintf(file,"%.2f %.2f %.2f 255 0 0\n",
				metrics->quad_x[i+1]+(metrics->quad_size/2.0),metrics->quad_y[i+1]+(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
			fprintf(file,"%.2f %.2f %.2f 255 0 0\n",
				metrics->quad_x[i+1]-(metrics->quad_size/2.0),metrics->quad_y[i+1]+(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
		}
	}
	
	// Create Edges
	for (int i = 0; i < metrics->nquad; i++) {
		
		// Check quad 2D area is sufficient to include quad
		if (metrics->area2D[i+1][0] >= (keep_area_thresh*metrics->quad_size*metrics->quad_size) ) {
			fprintf(file,"%d %d 0 255 0\n",4*i,4*i+1);
			fprintf(file,"%d %d 0 255 0\n",4*i+1,4*i+2);
			fprintf(file,"%d %d 0 255 0\n",4*i+2,4*i+3);
			fprintf(file,"%d %d 0 255 0\n",4*i+3,4*i);
		}
		else {
			fprintf(file,"%d %d 255 0 0\n",4*i,4*i+1);
			fprintf(file,"%d %d 255 0 0\n",4*i+1,4*i+2);
			fprintf(file,"%d %d 255 0 0\n",4*i+2,4*i+3);
			fprintf(file,"%d %d 255 0 0\n",4*i+3,4*i);
		}
		
	}
	
	// close file
	if (fclose(file)) {
		printf("file close error ...\n");
		return -1;
	}
	
	return 0;
}*/

// CreateQuadCoordsPLY - Create ply with lines outlining quadrat positions (updated for output quadrats as quad faces)
int CreateQuadCoordsPLY(char *filepath, Metrics *metrics, double keep_area_thresh)
{
	
	FILE *file;
	
	// Open file
	if (!(file = fopen(filepath, "w" ))) {
		printf("file open error (metrics.csv) ...\n");
		return -1;
	}
	
	// write PLY header
	fprintf(file,"ply\n");
	fprintf(file,"format ascii 1.0\n");
	fprintf(file,"element vertex %d\n",4*metrics->nquad);
	fprintf(file,"property float x\n");
	fprintf(file,"property float y\n");
	fprintf(file,"property float z\n");
	fprintf(file,"property uchar red\n");
	fprintf(file,"property uchar green\n");
	fprintf(file,"property uchar blue\n");
	fprintf(file,"element face %d\n",metrics->nquad);
	fprintf(file,"property list uchar int vertex_indices\n");
	fprintf(file,"end_header\n");
	
	double display_height = 1.0;
	
	// Create vertices
	for (int i = 0; i < metrics->nquad; i++) {
		if (metrics->area2D[i+1][0] >= (keep_area_thresh*metrics->quad_size*metrics->quad_size) ) {
			fprintf(file,"%.2f %.2f %.2f 0 255 0\n",
				metrics->quad_x[i+1]-(metrics->quad_size/2.0),metrics->quad_y[i+1]-(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
			fprintf(file,"%.2f %.2f %.2f 0 255 0\n",
				metrics->quad_x[i+1]+(metrics->quad_size/2.0),metrics->quad_y[i+1]-(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
			fprintf(file,"%.2f %.2f %.2f 0 255 0\n",
				metrics->quad_x[i+1]+(metrics->quad_size/2.0),metrics->quad_y[i+1]+(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
			fprintf(file,"%.2f %.2f %.2f 0 255 0\n",
				metrics->quad_x[i+1]-(metrics->quad_size/2.0),metrics->quad_y[i+1]+(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
		}
		else {
			fprintf(file,"%.2f %.2f %.2f 255 0 0\n",
				metrics->quad_x[i+1]-(metrics->quad_size/2.0),metrics->quad_y[i+1]-(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
			fprintf(file,"%.2f %.2f %.2f 255 0 0\n",
				metrics->quad_x[i+1]+(metrics->quad_size/2.0),metrics->quad_y[i+1]-(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
			fprintf(file,"%.2f %.2f %.2f 255 0 0\n",
				metrics->quad_x[i+1]+(metrics->quad_size/2.0),metrics->quad_y[i+1]+(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
			fprintf(file,"%.2f %.2f %.2f 255 0 0\n",
				metrics->quad_x[i+1]-(metrics->quad_size/2.0),metrics->quad_y[i+1]+(metrics->quad_size/2.0),
				metrics->quad_mean_h[i+1]+display_height);
		}
	}
	
	// Create Faces
	for (int i = 0; i < metrics->nquad; i++) {
		
		fprintf(file,"4 %d %d %d %d\n",4*i,4*i+1,4*i+2,4*i+3);
		/*// Check quad 2D area is sufficient to include quad
		if (metrics->area2D[i+1][0] >= (keep_area_thresh*metrics->quad_size*metrics->quad_size) ) {
			fprintf(file,"%d %d 0 255 0\n",4*i,4*i+1);
			fprintf(file,"%d %d 0 255 0\n",4*i+1,4*i+2);
			fprintf(file,"%d %d 0 255 0\n",4*i+2,4*i+3);
			fprintf(file,"%d %d 0 255 0\n",4*i+3,4*i);
		}
		else {
			fprintf(file,"%d %d 255 0 0\n",4*i,4*i+1);
			fprintf(file,"%d %d 255 0 0\n",4*i+1,4*i+2);
			fprintf(file,"%d %d 255 0 0\n",4*i+2,4*i+3);
			fprintf(file,"%d %d 255 0 0\n",4*i+3,4*i);
		}*/
		
	}
	
	// close file
	if (fclose(file)) {
		printf("file close error ...\n");
		return -1;
	}
	
	return 0;
}

void FreeMetrics(Metrics *metrics) 
{
	free(metrics->quad_coordx);
	free(metrics->quad_coordy);
	free(metrics->quad_x);
	free(metrics->quad_y);
	free(metrics->quad_mean_h);
	free(metrics->numfaces);
	free(metrics->numverts);
	for (int i = 0; i < 18; i++) {
		free(metrics->vertangle_bins[i]);
	}
	free(metrics->vertangle_bins);
	free(metrics->vertangle_mean);
	free(metrics->vertangle_std);
	free(metrics->fitted_slope);
	
	if (metrics->nresolutions > 0) {
		free(metrics->resolutions);
	}
	for (int i = 0; i < (metrics->nquad+1); i++) {
		free(metrics->area2D[i]);
		free(metrics->area2Dplane[i]);
    	free(metrics->area3D[i]);
    	free(metrics->rugosity[i]);
    	free(metrics->rugosityplane[i]);
    	free(metrics->height_std[i]);
    	free(metrics->height_range[i]);
	}
    free(metrics->area2D);
    free(metrics->area2Dplane);
    free(metrics->area3D);
    free(metrics->rugosity);
    free(metrics->rugosityplane);
    free(metrics->height_std);
    free(metrics->height_range);
}

int main(int argc, char **argv) 
{
    
    char filepath[2048];
    
    Points3D points3d;
    TriData tridata;
   	Points3D points3d_quad;
   	Points3D points3d_fitted;
   	
   	Points3D points3d_resampled;
   	TriData tridata_resampled;
   	
   	Metrics metrics;
   	
    // Check arguements
	if (!( (argc == 5) || (argc == 6) || (argc == 7) )) {
		printf("Usage: complexitymetrics <plyfile> <quadrat_size> <spacing> <output_dir> <Quad Keep Area Ratio Threshold [optional]> <resolutions.txt [optional]>\n");
		printf("======================\n");
		printf("\n");
		return -1;
    }
	
	printf("complexitymetrics: Loading data ...\n");
	
	// Read in ply file for terrain structure
	if (GetPointsfromSinglePly(argv[1], &points3d, &tridata) != 0) {
		printf("complexitymetrics: Can't read surface.ply file ...\n");
		return -1;
	}
	
	// get quadrat size/spacing
	metrics.quad_size = atof(argv[2]);
	double spacing = atof(argv[3]);
	
	// Make output directory if it doesn't exist yet
	char *output_dir = argv[4];
	sprintf(filepath,"%s",output_dir);
	#ifdef WIN32
   		mkdir(filepath);
   	#else
   		mkdir(filepath, S_IRWXU | S_IRWXG | S_IRWXO);
   	#endif
	
	#ifdef WIN32
		sprintf(filepath,"%s\\ds_plys",output_dir);
		mkdir(filepath);
	#else
		sprintf(filepath,"%s/ds_plys",output_dir);
		mkdir(filepath, S_IRWXU | S_IRWXG | S_IRWXO);
	#endif
	
	// Area threshold (as fraction of quadrat area) for deciding on when to keep quadrats in output
	double keep_area_thresh;
	if (argc >= 6) {
		keep_area_thresh = atof(argv[5]);
    }
    else {
    	keep_area_thresh = 0.75;
    }
	
	if (argc >= 7) {
		// Read resolutions file
    	if (ReadResolutions(argv[6], &metrics) != 0) {
        	printf("complexitymetrics: Can't read resolutions.txt file ...\n");
        	return -1;
    	}
    }
    else {
    	metrics.nresolutions = 0;
    }
	
	printf("complexitymetrics: Data loaded, terrain points/faces: %d/%d ...\n",points3d.n,tridata.n);
   	
   	// Compute extents of model
   	double BoundCoords[4];
   	BoundCoords[0] = min(points3d.X,points3d.n);
   	BoundCoords[1] = max(points3d.X,points3d.n);
   	BoundCoords[2] = min(points3d.Y,points3d.n);
   	BoundCoords[3] = max(points3d.Y,points3d.n);
   	printf("Bounding Coords: [%f %f %f %f]\n",BoundCoords[0],BoundCoords[1],BoundCoords[2],BoundCoords[3]);
   	
   	double cent_mesh_x = BoundCoords[0] + (BoundCoords[1]-BoundCoords[0])/2.0;
   	double cent_mesh_y = BoundCoords[2] + (BoundCoords[3]-BoundCoords[2])/2.0;
   	
   	////////////////////
   	// Workout quadrats
   	
   	// TODO: Need to clean this up
   	
   	int n_extx, n_exty;
   	if ( (metrics.quad_size > (BoundCoords[1]-BoundCoords[0]) ) && (metrics.quad_size > (BoundCoords[3]-BoundCoords[2]) ) ) {
   		// single quadrat larger than mesh, so just don't output quadrat data
   		n_extx = 0;
   		n_exty = 0;
   		metrics.nquad = 0;
   	}
   	else {
   		if (spacing == 0.0) {
   			printf("complexitymetrics: can't have zero quadrat spacing unless quadrat size is larger than mesh ...\n");
			return -1;
   		}
   		n_extx = 2*ceil(((BoundCoords[1]-BoundCoords[0])/2.0-(metrics.quad_size/2.0))/spacing) + 1;
   		n_exty = 2*ceil(((BoundCoords[3]-BoundCoords[2])/2.0-(metrics.quad_size/2.0))/spacing) + 1;
   		metrics.nquad = n_extx*n_exty;
   	}
   	
   	// Initialise arrays of data for storing triangles for each quadrat
   	int *trilist_quadrat = (int*)malloc(tridata.n*sizeof(int));
   	for (int i = 0; i < tridata.n; i++) {
   		trilist_quadrat[i] = i;
   	}
   	
   	// Initialise array of data for providing reference index of subsampled pointclouds
   	// in original full mesh pointcloud
   	int *point_index = (int*)malloc(points3d.n*sizeof(int));
   	for (int i = 0; i < points3d.n; i++) {
   		point_index[i] = i;
   	}
   	
   	// Initialise arrays of data for storing heights for quadrat faces
   	double *quadratface_heights = (double*)malloc(tridata.n*sizeof(double));
   	
   	// Initialise memory for points inside each quadrat (used for counting and plane fitting)
   	points3d_quad.X = (double*)malloc(points3d.n*sizeof(double));
	points3d_quad.Y = (double*)malloc(points3d.n*sizeof(double));
	points3d_quad.Z = (double*)malloc(points3d.n*sizeof(double));
   	
   	// Initialise memory for storing coordinate transforms for each plane of best fit
   	double **R = (double**)malloc((metrics.nquad+1)*sizeof(double*));
   	for (int i = 0; i < (metrics.nquad+1); i++) {
   		R[i] = (double*)malloc(9*sizeof(double));
   	}
   	
   	// Initialise grid for recording 2D projected area
   	GridMap areagridmap;
   	
    areagridmap.nx = 100;
    areagridmap.ny = 100;
    
    areagridmap.grid_heights = (double**)malloc(areagridmap.nx*sizeof(double*));
    areagridmap.grid_occ = (int**)malloc(areagridmap.nx*sizeof(int*));
    for (int i = 0; i < areagridmap.nx; i++) {
        areagridmap.grid_heights[i] = (double*)malloc(areagridmap.ny*sizeof(double));
        areagridmap.grid_occ[i] = (int*)malloc(areagridmap.ny*sizeof(int));
        for (int j = 0; j < areagridmap.ny; j++) {
            areagridmap.grid_occ[i][j] = -1;
        }
    }
   	
   	////////////////////////////////////////////
   	// Compute metrics on top resolution data
   	
   	printf("complexitymetrics: Computing metrics on original mesh scale ...\n");
   	
   	// Initialise memory for storing metrics
   	metrics.quad_coordx = (int*)malloc((metrics.nquad+1)*sizeof(int));
	metrics.quad_coordy = (int*)malloc((metrics.nquad+1)*sizeof(int));
	metrics.quad_x = (double*)malloc((metrics.nquad+1)*sizeof(double));
	metrics.quad_y = (double*)malloc((metrics.nquad+1)*sizeof(double));
	metrics.quad_mean_h = (double*)malloc((metrics.nquad+1)*sizeof(double));
	metrics.numfaces = (int*)malloc((metrics.nquad+1)*sizeof(int));
	metrics.numverts = (int*)malloc((metrics.nquad+1)*sizeof(int));
	metrics.vertangle_bins = (double**)malloc(18*sizeof(double*));
	for (int j = 0; j < 18; j++) {
		metrics.vertangle_bins[j] = (double*)malloc((metrics.nquad+1)*sizeof(double));
	}
	metrics.vertangle_mean = (double*)malloc((metrics.nquad+1)*sizeof(double));
	metrics.vertangle_std = (double*)malloc((metrics.nquad+1)*sizeof(double));
	metrics.fitted_slope = (double*)malloc((metrics.nquad+1)*sizeof(double));
   	
   	metrics.area2D = (double**)malloc((metrics.nquad+1)*sizeof(double*));
   	metrics.area2Dplane = (double**)malloc((metrics.nquad+1)*sizeof(double*));
   	metrics.area3D = (double**)malloc((metrics.nquad+1)*sizeof(double*));
   	metrics.rugosity = (double**)malloc((metrics.nquad+1)*sizeof(double*));
   	metrics.rugosityplane = (double**)malloc((metrics.nquad+1)*sizeof(double*));
   	metrics.height_std = (double**)malloc((metrics.nquad+1)*sizeof(double*));
   	metrics.height_range = (double**)malloc((metrics.nquad+1)*sizeof(double*));
   	for (int j = 0; j < (metrics.nquad+1); j++) {
		metrics.area2D[j] = (double*)malloc((metrics.nresolutions+1)*sizeof(double));
		metrics.area2Dplane[j] = (double*)malloc((metrics.nresolutions+1)*sizeof(double));
   		metrics.area3D[j] = (double*)malloc((metrics.nresolutions+1)*sizeof(double));
   		metrics.rugosity[j] = (double*)malloc((metrics.nresolutions+1)*sizeof(double));
   		metrics.rugosityplane[j] = (double*)malloc((metrics.nresolutions+1)*sizeof(double));
   		metrics.height_std[j] = (double*)malloc((metrics.nresolutions+1)*sizeof(double));
   		metrics.height_range[j] = (double*)malloc((metrics.nresolutions+1)*sizeof(double));
	}
   	
   	// Whole mesh values
   	metrics.quad_coordx[0] = -1;
	metrics.quad_coordy[0] = -1;
	metrics.quad_x[0] = cent_mesh_x;
	metrics.quad_y[0] = cent_mesh_y;
	metrics.numfaces[0] = tridata.n;
	metrics.numverts[0] = points3d.n;
	
	// Setup for calculating 2D area
	if ( (BoundCoords[1]-BoundCoords[0]) > (BoundCoords[3]-BoundCoords[2]) ) {
		areagridmap.grid_res = (BoundCoords[1]-BoundCoords[0])/100.0;
	}
	else {
		areagridmap.grid_res = (BoundCoords[3]-BoundCoords[2])/100.0;
	}
    areagridmap.xoffset = BoundCoords[0];
    areagridmap.yoffset = BoundCoords[2];
    
   	calc_area_metrics(&points3d, &tridata, trilist_quadrat, tridata.n, point_index, &metrics, 0, 0, &areagridmap, 0);
   	calc_relief_metrics(&points3d, &tridata, trilist_quadrat, tridata.n, &metrics, 0, 0, quadratface_heights);
	
	// Landscape slope
   	compute_planefit(&points3d, R[0], 1, &points3d_fitted);
   	if (R[0][8] > 1.0) {
   		metrics.landscape_slope = 0.0;
   	}
   	else {
   		metrics.landscape_slope = (180.0/M_PI)*acos(R[0][8]);
   	}
	metrics.fitted_slope[0] = metrics.landscape_slope;
	
	// Calculate area-based metrics on plane of best fit mesh
	double BoundCoords_fitted[4];
   	BoundCoords_fitted[0] = min(points3d_fitted.X,points3d_fitted.n);
   	BoundCoords_fitted[1] = max(points3d_fitted.X,points3d_fitted.n);
   	BoundCoords_fitted[2] = min(points3d_fitted.Y,points3d_fitted.n);
   	BoundCoords_fitted[3] = max(points3d_fitted.Y,points3d_fitted.n);
   	if ( (BoundCoords_fitted[1]-BoundCoords_fitted[0]) > (BoundCoords_fitted[3]-BoundCoords_fitted[2]) ) {
		areagridmap.grid_res = (BoundCoords_fitted[1]-BoundCoords_fitted[0]+0.001)/100.0;
	}
	else {
		areagridmap.grid_res = (BoundCoords_fitted[3]-BoundCoords_fitted[2]+0.001)/100.0;
	}
    areagridmap.xoffset = BoundCoords_fitted[0];
    areagridmap.yoffset = BoundCoords_fitted[2];
   	
   	calc_area_metrics(&points3d_fitted, &tridata, trilist_quadrat, tridata.n, point_index, &metrics, 0, 0, &areagridmap, 1);
   	FreePoints3D(&points3d_fitted);
	
	calc_vertangle_metrics(&points3d, &tridata, trilist_quadrat, tridata.n, &metrics, 0, quadratface_heights);
	
   	// cycle through quadrats, compute metrics for original mesh scale
   	int c = 1; // second row is first quadrat (first row is for whole mesh)
	for (int jx = 0; jx < n_extx; jx++) {
		for (int jy = 0; jy < n_exty; jy++) {
			
			printf("\rComputing Quadrat Data (Original Resolution) (%d/%d) of (%d/%d) ...",
   	             jx,jy,n_extx-1,n_exty-1);
            fflush(stdout);
			
			// Get quadrat details
			double centx = cent_mesh_x+spacing*(jx-(n_extx-1)/2);
			double centy = cent_mesh_y+spacing*(jy-(n_exty-1)/2);
			metrics.quad_coordx[c] = jx;
			metrics.quad_coordy[c] = jy;
			metrics.quad_x[c] = centx;
			metrics.quad_y[c] = centy;
			
			// Get triangles in quadrat
			int ntri = GetTriListWindow_Square(&points3d,&tridata,trilist_quadrat,centx,centy,metrics.quad_size);
			metrics.numfaces[c] = ntri;
			
			// Get Points in quadrat
			points3d_quad.n = 0;
			for (int i = 0; i < points3d.n; i++) {
				double qx = (points3d.X[i]-centx)/metrics.quad_size;
				double qy = (points3d.Y[i]-centy)/metrics.quad_size;
				if ( (qx >= -0.5) && (qx <= 0.5) && (qy >= -0.5) && (qy <= 0.5) ) {
					points3d_quad.X[points3d_quad.n] = points3d.X[i];
					points3d_quad.Y[points3d_quad.n] = points3d.Y[i];
					points3d_quad.Z[points3d_quad.n] = points3d.Z[i];
					point_index[i] = points3d_quad.n;
					points3d_quad.n++;
				}
			}
			metrics.numverts[c] = points3d_quad.n;
			
			// Setup for calculating 2D area
			areagridmap.grid_res = (metrics.quad_size)/100.0;
    		areagridmap.xoffset = centx-(metrics.quad_size/2);
    		areagridmap.yoffset = centy-(metrics.quad_size/2);
			
			// Calculate metrics for quadrat
			calc_area_metrics(&points3d_quad, &tridata, trilist_quadrat, ntri, point_index, &metrics, c, 0, &areagridmap, 0);
   			calc_relief_metrics(&points3d, &tridata, trilist_quadrat, ntri, &metrics, c, 0, quadratface_heights);
			calc_vertangle_metrics(&points3d, &tridata, trilist_quadrat, ntri, &metrics, c, quadratface_heights);
			
			// Get quadrat fitted slope
			if (points3d_quad.n > 4) {
				compute_planefit(&points3d_quad, R[c], 1, &points3d_fitted);
				if (R[c][8] > 1.0) {
					metrics.fitted_slope[c] = 0.0;
				}
				else {
					metrics.fitted_slope[c] = (180.0/M_PI)*acos(R[c][8]);
				}
				
				// Get area based metrics for plane of best fit
				BoundCoords_fitted[0] = min(points3d_fitted.X,points3d_fitted.n);
				BoundCoords_fitted[1] = max(points3d_fitted.X,points3d_fitted.n);
				BoundCoords_fitted[2] = min(points3d_fitted.Y,points3d_fitted.n);
				BoundCoords_fitted[3] = max(points3d_fitted.Y,points3d_fitted.n);
				if ( (BoundCoords_fitted[1]-BoundCoords_fitted[0]) > (BoundCoords_fitted[3]-BoundCoords_fitted[2]) ) {
					areagridmap.grid_res = (BoundCoords_fitted[1]-BoundCoords_fitted[0]+0.001)/100.0;
				}
				else {
					areagridmap.grid_res = (BoundCoords_fitted[3]-BoundCoords_fitted[2]+0.001)/100.0;
				}
				areagridmap.xoffset = BoundCoords_fitted[0];
				areagridmap.yoffset = BoundCoords_fitted[2];
			
				calc_area_metrics(&points3d_fitted, &tridata, trilist_quadrat, ntri, point_index, &metrics, c, 0, &areagridmap, 1);
				FreePoints3D(&points3d_fitted);
				
			}
			else {
				metrics.fitted_slope[c] = -1.0;
				metrics.area2Dplane[c][0] = 0.0;
				metrics.rugosityplane[c][0] = -1.0;
			}
			
			c++;
		}
	}
	printf("\n");
   	
   	////////////////////////////////////////////
   	// compute metrics for down-sampled meshes
   	
   	printf("complexitymetrics: Computing metrics on re-sampled meshes ...\n");
   	
   	double P[3], P2[3];
   	
   	// Cycle through resolutions
	for (int ri = 0; ri < metrics.nresolutions; ri++) {
   		
   		printf("\rComputing Quadrat Data (Res: %f (%d/%d)) (full mesh) ...",
			metrics.resolutions[ri],ri+1,metrics.nresolutions);
        fflush(stdout);
   		
		// Downsample surface
		Resample_GridTri(&points3d, &tridata, metrics.resolutions[ri],
			&points3d_resampled, &tridata_resampled, 0.00001, 0.00001);
		
		// re-create pointlist
		if (points3d_resampled.n > points3d.n) {
			point_index = (int*)realloc(point_index,points3d_resampled.n*sizeof(int));
			points3d_quad.X = (double*)realloc(points3d_quad.X,points3d_resampled.n*sizeof(double));
			points3d_quad.Y = (double*)realloc(points3d_quad.Y,points3d_resampled.n*sizeof(double));
			points3d_quad.Z = (double*)realloc(points3d_quad.Z,points3d_resampled.n*sizeof(double));
		}
		for (int i = 0; i < points3d_resampled.n; i++) {
			point_index[i] = i;
		}
		
		// Output down-sampled mesh (for testing)
		#ifdef WIN32
			sprintf(filepath,"%s\\ds_plys\\surface_ds%.03d.ply",output_dir,ri);
		#else
			sprintf(filepath,"%s/ds_plys/surface_ds%.03d.ply",output_dir,ri);
		#endif
        if (CreateTotalTriPly(filepath, &points3d_resampled, &tridata_resampled) != 0) {
            printf("complexitymetrics: error writing ply file ...\n");
            return -1;
        }
		
		// Calculate whole mesh at this resolution
		if (tridata_resampled.n > tridata.n) {
			quadratface_heights = (double*)realloc(quadratface_heights,tridata_resampled.n*sizeof(double));
			trilist_quadrat = (int*)realloc(trilist_quadrat,tridata_resampled.n*sizeof(int));
		}
		for (int i = 0; i < tridata_resampled.n; i++) {
   			trilist_quadrat[i] = i;
   		}
		
		// Setup for calculating 2D area
		if ( (BoundCoords[1]-BoundCoords[0]) > (BoundCoords[3]-BoundCoords[2]) ) {
			areagridmap.grid_res = (BoundCoords[1]-BoundCoords[0])/100.0;
		}
		else {
			areagridmap.grid_res = (BoundCoords[3]-BoundCoords[2])/100.0;
		}
		areagridmap.xoffset = BoundCoords[0];
		areagridmap.yoffset = BoundCoords[2];
		
		calc_area_metrics(&points3d_resampled, &tridata_resampled, trilist_quadrat, tridata_resampled.n, point_index, &metrics, 0, ri+1, &areagridmap, 0);
		calc_relief_metrics(&points3d_resampled, &tridata_resampled, trilist_quadrat, tridata_resampled.n, &metrics, 0, ri+1, quadratface_heights);
		
		if (metrics.fitted_slope[0] == -1.0) {
			metrics.area2Dplane[0][ri+1] = 0.0;
			metrics.rugosityplane[0][ri+1] = -1.0;
		}
		else {
		
			// get plane of best fit transformed points and compute plane of best fit metrics
			for (int i = 0; i < points3d_resampled.n; i++) {
				P[0] = points3d_resampled.X[i];
				P[1] = points3d_resampled.Y[i];
				P[2] = points3d_resampled.Z[i];
				MatVectorMult3x3(R[0], P, P2);
				points3d_quad.X[i] = P2[0]; // using points3d_quad here to save on memory allocation
				points3d_quad.Y[i] = P2[1];
				points3d_quad.Z[i] = P2[2];
			}
			points3d_quad.n = points3d_resampled.n;
		
			// Calculate area-based metrics on plane of best fit mesh
			BoundCoords_fitted[0] = min(points3d_quad.X,points3d_quad.n);
			BoundCoords_fitted[1] = max(points3d_quad.X,points3d_quad.n);
			BoundCoords_fitted[2] = min(points3d_quad.Y,points3d_quad.n);
			BoundCoords_fitted[3] = max(points3d_quad.Y,points3d_quad.n);
			if ( (BoundCoords_fitted[1]-BoundCoords_fitted[0]) > (BoundCoords_fitted[3]-BoundCoords_fitted[2]) ) {
				areagridmap.grid_res = (BoundCoords_fitted[1]-BoundCoords_fitted[0])/100.0;
			}
			else {
				areagridmap.grid_res = (BoundCoords_fitted[3]-BoundCoords_fitted[2])/100.0;
			}
			areagridmap.xoffset = BoundCoords_fitted[0];
			areagridmap.yoffset = BoundCoords_fitted[2];
		
			calc_area_metrics(&points3d_quad, &tridata_resampled, trilist_quadrat, tridata_resampled.n, point_index, &metrics, 0, ri+1, &areagridmap, 1);
		
		}
		
		// cycle through quadrats, compute data for this resolution
		int c = 1;
		for (int jx = 0; jx < n_extx; jx++) {
			for (int jy = 0; jy < n_exty; jy++) {
				
				printf("\rComputing Quadrat Data (Res: %f (%d/%d)) (%d/%d) of (%d/%d) ...",
					metrics.resolutions[ri],ri+1,metrics.nresolutions,jx,jy,n_extx-1,n_exty-1);
            	fflush(stdout);
				
				// Get quadrat details
				double centx = cent_mesh_x+spacing*(jx-(n_extx-1)/2);
				double centy = cent_mesh_y+spacing*(jy-(n_exty-1)/2);
	
				// Get triangles in quadrat
				int ntri = GetTriListWindow_Square(&points3d_resampled,&tridata_resampled,trilist_quadrat,centx,centy,metrics.quad_size);
				
				// Setup for calculating 2D area
				areagridmap.grid_res = (metrics.quad_size)/100.0;
				areagridmap.xoffset = centx-(metrics.quad_size/2);
				areagridmap.yoffset = centy-(metrics.quad_size/2);
				
				// Calculate metrics for quadrat
				for (int i = 0; i < points3d_resampled.n; i++) {
					point_index[i] = i;
				}
				calc_area_metrics(&points3d_resampled, &tridata_resampled, trilist_quadrat, ntri, point_index, &metrics, c, ri+1, &areagridmap, 0);
				calc_relief_metrics(&points3d_resampled, &tridata_resampled, trilist_quadrat, ntri, &metrics, c, ri+1, quadratface_heights);
				
				if (metrics.fitted_slope[c] == -1.0) {
					metrics.area2Dplane[c][ri+1] = 0.0;
					metrics.rugosityplane[c][ri+1] = -1.0;
				}
				else {
				
					// Get Points in quadrat, transform coordinates to plane of best fit
					points3d_quad.n = 0;
					for (int i = 0; i < points3d_resampled.n; i++) {
						double qx = (points3d_resampled.X[i]-centx)/metrics.quad_size;
						double qy = (points3d_resampled.Y[i]-centy)/metrics.quad_size;
						if ( (qx >= -0.5) && (qx <= 0.5) && (qy >= -0.5) && (qy <= 0.5) ) {
							P[0] = points3d_resampled.X[i];
							P[1] = points3d_resampled.Y[i];
							P[2] = points3d_resampled.Z[i];
							MatVectorMult3x3(R[c], P, P2);
							points3d_quad.X[points3d_quad.n] = P2[0];
							points3d_quad.Y[points3d_quad.n] = P2[1];
							points3d_quad.Z[points3d_quad.n] = P2[2];
							point_index[i] = points3d_quad.n;
							points3d_quad.n++;
						}
					}
					
					// Calculate area-based metrics on plane of best fit mesh
					BoundCoords_fitted[0] = min(points3d_quad.X,points3d_quad.n);
					BoundCoords_fitted[1] = max(points3d_quad.X,points3d_quad.n);
					BoundCoords_fitted[2] = min(points3d_quad.Y,points3d_quad.n);
					BoundCoords_fitted[3] = max(points3d_quad.Y,points3d_quad.n);
					if ( (BoundCoords_fitted[1]-BoundCoords_fitted[0]) > (BoundCoords_fitted[3]-BoundCoords_fitted[2]) ) {
						areagridmap.grid_res = (BoundCoords_fitted[1]-BoundCoords_fitted[0]+0.001)/100.0;
					}
					else {
						areagridmap.grid_res = (BoundCoords_fitted[3]-BoundCoords_fitted[2]+0.001)/100.0;
					}
					areagridmap.xoffset = BoundCoords_fitted[0];
					areagridmap.yoffset = BoundCoords_fitted[2];
					
					//printf("here4: %f %f %f\n",areagridmap.grid_res,areagridmap.xoffset,areagridmap.yoffset);
					
					calc_area_metrics(&points3d_quad, &tridata_resampled, trilist_quadrat, ntri, point_index, &metrics, c, ri+1, &areagridmap, 1);
					
				}
				
				c++;
			}
		}
		printf("\n");
		
		// Clean up
		//printf("hello: %d %d\n", points3d_resampled.n, tridata_resampled.n);
		FreePoints3D(&points3d_resampled);
		FreeTriData(&tridata_resampled);
		//printf("done\n");
		
    }
   	
   	/////////////////////////////////
   	// Save out metrics to csv file
   	
   	printf("complexitymetrics: Saving output to csv ...\n");
   	
   	#ifdef WIN32
		sprintf(filepath,"%s\\metrics.csv",output_dir);
	#else
		sprintf(filepath,"%s/metrics.csv",output_dir);
	#endif
   	if (WriteMetricstoCSV(filepath, &metrics, BoundCoords, output_dir, keep_area_thresh) != 0) {
		printf("complexitymetrics: Error writing output CSV ...\n");
		return -1;
	}
   	
   	// Also save out PLY file displaying quadrat locations
   	#ifdef WIN32
		sprintf(filepath,"%s\\quadrats.ply",output_dir);
	#else
		sprintf(filepath,"%s/quadrats.ply",output_dir);
	#endif
   	if (CreateQuadCoordsPLY(filepath, &metrics, keep_area_thresh) != 0) {
		printf("complexitymetrics: Error writing quadrats PLY ...\n");
		return -1;
	}
   	
   	printf("complexitymetrics: Finished!\n");
   	
   	// Clean up
   	FreeMetrics(&metrics);
    FreePoints3D(&points3d);
    FreePoints3D(&points3d_quad);
    FreeTriData(&tridata);
    free(trilist_quadrat);
    free(point_index);
    free(R);
    free(quadratface_heights);
    FreeGridMap(&areagridmap);
    
    return 0;
    
}

